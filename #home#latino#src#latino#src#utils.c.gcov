        -:    0:Source:/home/latino/src/latino/src/utils.c
        -:    0:Programs:13
        -:    1:/*
        -:    2:The MIT License (MIT)
        -:    3:
        -:    4:Copyright (c) 2015 - Latino
        -:    5:
        -:    6:Permission is hereby granted, free of charge, to any person obtaining a copy
        -:    7:of this software and associated documentation files (the "Software"), to deal
        -:    8:in the Software without restriction, including without limitation the rights
        -:    9:to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        -:   10:copies of the Software, and to permit persons to whom the Software is
        -:   11:furnished to do so, subject to the following conditions:
        -:   12:
        -:   13:The above copyright notice and this permission notice shall be included in
        -:   14:all copies or substantial portions of the Software.
        -:   15:
        -:   16:THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        -:   17:IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        -:   18:FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        -:   19:AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        -:   20:LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        -:   21:OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
        -:   22:THE SOFTWARE.
        -:   23:*/
        -:   24:
        -:   25:#include <stdio.h>
        -:   26:#include <stdlib.h>
        -:   27:#include <string.h>
        -:   28:#include <ctype.h>
        -:   29:
        -:   30:#include "latino.h"
        -:   31:#include "ast.h"
        -:   32:#include "utils.h"
        -:   33:#include "libmem.h"
        -:   34:
function strdup0 called 129 returned 100% blocks executed 100%
      129:   35:char* strdup0(const char* s)
        -:   36:{
      129:   37:    size_t len = strlen(s);
        -:   38:    char* p;
      129:   39:    p = lat_asignar_memoria(len + 1);
call    0 returned 100%
      129:   40:    if (p)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   41:    {
      129:   42:        strncpy(p, s, len);
        -:   43:    }
      129:   44:    p[len] = '\0';
      129:   45:    return p;
        -:   46:}
        -:   47:
function parse_string called 12 returned 100% blocks executed 47%
       12:   48:char* parse_string(const char* s, size_t len)
        -:   49:{
       12:   50:    char* ret = lat_asignar_memoria(len + 1);
call    0 returned 100%
        -:   51:    int i = 0;
        -:   52:    int j = 0;
        -:   53:    int c = '@';
      330:   54:    for (i = 0; i < len; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:   55:    {
      318:   56:        switch (s[i])
branch  0 taken 0%
branch  1 taken 100%
        -:   57:        {
        -:   58:        case '\\':
        -:   59:        {
    #####:   60:            switch (s[i + 1])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:   61:            {
        -:   62:            case 'a':
        -:   63:                c = '\n';
    #####:   64:                i++;
    #####:   65:                goto save;
        -:   66:            case 'b':
        -:   67:                c = '\n';
    #####:   68:                i++;
    #####:   69:                goto save;
        -:   70:            case 'f':
        -:   71:                c = '\n';
    #####:   72:                i++;
    #####:   73:                goto save;
        -:   74:            case 'n':
        -:   75:                c = '\n';
    #####:   76:                i++;
    #####:   77:                goto save;
        -:   78:            case 'r':
        -:   79:                c = '\n';
    #####:   80:                i++;
    #####:   81:                goto save;
        -:   82:            case 't':
        -:   83:                c = '\t';
    #####:   84:                i++;
    #####:   85:                goto save;
        -:   86:            case 'v':
        -:   87:                c = '\n';
    #####:   88:                i++;
    #####:   89:                goto save;
        -:   90:            default:
        -:   91:                break;
        -:   92:            }
        -:   93:        }
        -:   94:        break;
        -:   95:        default:
      318:   96:            c = s[i];
      318:   97:            break;
        -:   98:        }
        -:   99:save:
      318:  100:        ret[j] = c;
      318:  101:        j++;
        -:  102:    }
       12:  103:    ret[j] = '\0';
       12:  104:    return ret;
        -:  105:}
        -:  106:
function concat called 0 returned 0% blocks executed 0%
    #####:  107:char* concat(char* s1, char* s2)
        -:  108:{
    #####:  109:    char* s3 = malloc(strlen(s1) + strlen(s2) + 1);
    #####:  110:    strcpy(s3, s1);
    #####:  111:    strcat(s3, s2);
    #####:  112:    return s3;
        -:  113:}
        -:  114:
function int2str called 0 returned 0% blocks executed 0%
    #####:  115:char* int2str(long i)
        -:  116:{
        -:  117:    char s[255];
    #####:  118:    char* r = malloc(strlen(s) + 1);
    #####:  119:    snprintf(s, 255, "%ld", i);
    #####:  120:    strcpy(r, s);
    #####:  121:    return r;
        -:  122:}
        -:  123:
function double2str called 0 returned 0% blocks executed 0%
    #####:  124:char* double2str(double d)
        -:  125:{
        -:  126:    char s[64];
    #####:  127:    char* r = malloc(strlen(s) + 1);
    #####:  128:    snprintf(s, 64, "%g", (float)d);
    #####:  129:    strcpy(r, s);
    #####:  130:    return r;
        -:  131:}
        -:  132:
function char2str called 0 returned 0% blocks executed 0%
    #####:  133:char* char2str(char c)
        -:  134:{
        -:  135:    char s[2];
    #####:  136:    char* r = malloc(2);
    #####:  137:    snprintf(s, 2, "%c", c);
    #####:  138:    strcpy(r, s);
    #####:  139:    return r;
        -:  140:}
        -:  141:
function bool2str called 0 returned 0% blocks executed 0%
    #####:  142:char* bool2str(int i)
        -:  143:{
        -:  144:    char s[10];
    #####:  145:    char* r = malloc(11);
    #####:  146:    if (i)
branch  0 never executed
branch  1 never executed
        -:  147:    {
    #####:  148:        snprintf(s, 10, "%s", "verdadero");
    #####:  149:        strcpy(r, s);
        -:  150:    }
        -:  151:    else
        -:  152:    {
    #####:  153:        snprintf(s, 10, "%s", "falso");
    #####:  154:        strcpy(r, s);
        -:  155:    }
    #####:  156:    return r;
        -:  157:}
        -:  158:
function startsWith called 0 returned 0% blocks executed 0%
    #####:  159:bool startsWith(const char* base, const char* str)
        -:  160:{
    #####:  161:    return (strstr(base, str) - base) == 0;
        -:  162:}
        -:  163:
function endsWith called 0 returned 0% blocks executed 0%
    #####:  164:bool endsWith(char* base, char* str)
        -:  165:{
    #####:  166:    int blen = strlen(base);
    #####:  167:    int slen = strlen(str);
    #####:  168:    return (blen >= slen) && (0 == strcmp(base + blen - slen, str));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  169:}
        -:  170:
function indexOf called 0 returned 0% blocks executed 0%
    #####:  171:int indexOf(char* base, char* str)
        -:  172:{
    #####:  173:    return indexOf_shift(base, str, 0);
call    0 never executed
        -:  174:}
        -:  175:
function indexOf_shift called 0 returned 0% blocks executed 0%
    #####:  176:int indexOf_shift(char* base, char* str, int startIndex)
        -:  177:{
        -:  178:    int result;
    #####:  179:    int baselen = strlen(base);
    #####:  180:    if ((int)strlen(str) > baselen || startIndex > baselen)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  181:    {
        -:  182:        result = -1;
        -:  183:    }
        -:  184:    else
        -:  185:    {
    #####:  186:        if (startIndex < 0)
branch  0 never executed
branch  1 never executed
        -:  187:        {
        -:  188:            startIndex = 0;
        -:  189:        }
    #####:  190:        char* pos = strstr(base + startIndex, str);
    #####:  191:        if (pos == NULL)
branch  0 never executed
branch  1 never executed
        -:  192:        {
        -:  193:            result = -1;
        -:  194:        }
        -:  195:        else
        -:  196:        {
    #####:  197:            result = pos - base;
        -:  198:        }
        -:  199:    }
    #####:  200:    return result;
        -:  201:}
        -:  202:
function lastIndexOf called 0 returned 0% blocks executed 0%
    #####:  203:int lastIndexOf(char* base, char* str)
        -:  204:{
        -:  205:    int result;
    #####:  206:    if (strlen(str) > strlen(base))
branch  0 never executed
branch  1 never executed
        -:  207:    {
        -:  208:        result = -1;
        -:  209:    }
        -:  210:    else
        -:  211:    {
        -:  212:        int start = 0;
    #####:  213:        int endinit = strlen(base) - strlen(str);
        -:  214:        int end = endinit;
        -:  215:        int endtmp = endinit;
    #####:  216:        while (start != end)
branch  0 never executed
branch  1 never executed
        -:  217:        {
    #####:  218:            start = indexOf_shift(base, str, start);
call    0 never executed
    #####:  219:            end = indexOf_shift(base, str, end);
call    0 never executed
    #####:  220:            if (start == -1)
branch  0 never executed
branch  1 never executed
        -:  221:            {
        -:  222:                end = -1;
        -:  223:            }
    #####:  224:            else if (end == -1)
branch  0 never executed
branch  1 never executed
        -:  225:            {
    #####:  226:                if (endtmp == (start + 1))
branch  0 never executed
branch  1 never executed
        -:  227:                {
        -:  228:                    end = start;
        -:  229:                }
        -:  230:                else
        -:  231:                {
    #####:  232:                    end = endtmp - (endtmp - start) / 2;
    #####:  233:                    if (end <= start)
branch  0 never executed
branch  1 never executed
        -:  234:                    {
        -:  235:                        end = start + 1;
        -:  236:                    }
        -:  237:                    endtmp = end;
        -:  238:                }
        -:  239:            }
        -:  240:            else
        -:  241:            {
        -:  242:                start = end;
        -:  243:                end = endinit;
        -:  244:            }
        -:  245:        }
    #####:  246:        result = start;
        -:  247:    }
    #####:  248:    return result;
        -:  249:}
        -:  250:
function insert called 0 returned 0% blocks executed 0%
    #####:  251:char* insert(char *dest, char* src, int pos)
        -:  252:{
    #####:  253:    int srclen = strlen(src);
    #####:  254:    int dstlen = strlen(dest);
    #####:  255:    if (pos < 0)
branch  0 never executed
branch  1 never executed
        -:  256:    {
    #####:  257:        pos = dstlen + pos;
        -:  258:    }
    #####:  259:    if (pos > dstlen)
branch  0 never executed
branch  1 never executed
        -:  260:    {
        -:  261:        pos = dstlen;
        -:  262:    }
    #####:  263:    char *m = malloc(srclen + dstlen + 1);
    #####:  264:    memcpy(m, dest, pos);
    #####:  265:    memcpy(m + pos, src, srclen);
    #####:  266:    memcpy(m + pos + srclen, dest + pos, dstlen - pos + 1);
    #####:  267:    return m;
        -:  268:}
        -:  269:
function padLeft called 0 returned 0% blocks executed 0%
    #####:  270:char* padLeft(char* base, int n, char* c)
        -:  271:{
    #####:  272:    int len = (int)strlen(base);
        -:  273:    char *ret = NULL;
    #####:  274:    if (n <= len)
branch  0 never executed
branch  1 never executed
        -:  275:    {
    #####:  276:        ret = malloc(len + 1);
    #####:  277:        strcpy(ret, base);
    #####:  278:        return ret;
        -:  279:    }
        -:  280:    ret = malloc(n + 1);
        -:  281:    ret = "";
        -:  282:    int i = 0;
    #####:  283:    for (i = 0; i < (n - len); i++)
branch  0 never executed
branch  1 never executed
        -:  284:    {
    #####:  285:        ret = concat(ret, c);
call    0 never executed
        -:  286:    }
    #####:  287:    ret = concat(ret, base);
call    0 never executed
    #####:  288:    return ret;
        -:  289:}
        -:  290:
function padRight called 0 returned 0% blocks executed 0%
    #####:  291:char* padRight(char *base, int n, char* c)
        -:  292:{
    #####:  293:    int len = (int)strlen(base);
        -:  294:    char *ret = NULL;
    #####:  295:    if (len >= n)
branch  0 never executed
branch  1 never executed
        -:  296:    {
    #####:  297:        ret = malloc(len + 1);
    #####:  298:        strcpy(ret, base);
    #####:  299:        return ret;
        -:  300:    }
        -:  301:    ret = malloc(n + 1);
        -:  302:    ret = base;
        -:  303:    int i;
    #####:  304:    for (i = 0; i < (n - len); i++)
branch  0 never executed
branch  1 never executed
        -:  305:    {
    #####:  306:        ret = concat(ret, c);
call    0 never executed
        -:  307:    }
    #####:  308:    return ret;
        -:  309:}
        -:  310:
function replace called 0 returned 0% blocks executed 0%
    #####:  311:char *replace(char *str, char *orig, char *rep)
        -:  312:{
    #####:  313:    char *buffer = lat_asignar_memoria(MAX_STR_LENGTH);
call    0 never executed
        -:  314:    char *p;
    #####:  315:    if (!(p = strstr(str, orig)))
branch  0 never executed
branch  1 never executed
        -:  316:    {
        -:  317:        return str;
        -:  318:    }
    #####:  319:    strncpy(buffer, str, p - str);
    #####:  320:    buffer[p - str] = '\0';
    #####:  321:    sprintf(buffer + (p - str), "%s%s", rep, p + strlen(orig));
        -:  322:    //reemplazar todas las ocurrencias
    #####:  323:    if (strstr(buffer, orig) != NULL)
branch  0 never executed
branch  1 never executed
        -:  324:    {
    #####:  325:        strcpy(buffer, replace(buffer, orig, rep));
call    0 never executed
        -:  326:    }
    #####:  327:    return buffer;
        -:  328:}
        -:  329:
function substring called 0 returned 0% blocks executed 0%
    #####:  330:char *substring(const char* str, int beg, int n)
        -:  331:{
    #####:  332:    char *ret = malloc(n + 1);
    #####:  333:    strncpy(ret, (str + beg), n);
    #####:  334:    *(ret + n) = 0;
        -:  335:
    #####:  336:    return ret;
        -:  337:}
        -:  338:
function toLower called 0 returned 0% blocks executed 0%
    #####:  339:char *toLower(const char* str)
        -:  340:{
        -:  341:    int i = 0;
    #####:  342:    int len = strlen(str);
    #####:  343:    char *ret = (char*)malloc(len + 1);
    #####:  344:    for (i = 0; i < len; i++)
branch  0 never executed
branch  1 never executed
        -:  345:    {
    #####:  346:        ret[i] = tolower(str[i]);
call    0 never executed
        -:  347:    }
    #####:  348:    ret[len] = 0;
    #####:  349:    return ret;
        -:  350:}
        -:  351:
function toUpper called 0 returned 0% blocks executed 0%
    #####:  352:char *toUpper(const char* str)
        -:  353:{
        -:  354:    int i = 0;
    #####:  355:    int len = strlen(str);
    #####:  356:    char *ret = malloc(len + 1);
    #####:  357:    for (i = 0; i < len; i++)
branch  0 never executed
branch  1 never executed
        -:  358:    {
    #####:  359:        ret[i] = toupper(str[i]);
call    0 never executed
        -:  360:    }
    #####:  361:    ret[len] = 0;
    #####:  362:    return ret;
        -:  363:}
        -:  364:
function trim called 0 returned 0% blocks executed 0%
    #####:  365:char* trim(const char *str)
        -:  366:{
        -:  367:    char *start;
        -:  368:    char *end;
    #####:  369:    for (start = (char*) str; *start; start++)
branch  0 never executed
branch  1 never executed
        -:  370:    {
    #####:  371:        if (!isspace((unsigned char)start[0]))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  372:            break;
        -:  373:    }
    #####:  374:    for (end = start + strlen(start); end > start + 1; end--)
branch  0 never executed
branch  1 never executed
        -:  375:    {
    #####:  376:        if (!isspace((unsigned char)end[-1]))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  377:            break;
        -:  378:    }
    #####:  379:    char *ret = malloc((end - start) + 1);
    #####:  380:    *end = 0;
    #####:  381:    if (start > str)
branch  0 never executed
branch  1 never executed
        -:  382:    {
    #####:  383:        memcpy(ret, start, (end - start) + 1);
        -:  384:    }
        -:  385:    else
        -:  386:    {
    #####:  387:        memcpy(ret, str, strlen(str));
        -:  388:    }
    #####:  389:    return ret;
        -:  390:}
        -:  391:
function lat_crear_lista called 316 returned 100% blocks executed 100%
      316:  392:list_node* lat_crear_lista()
        -:  393:{
      316:  394:    list_node* start = (list_node*)lat_asignar_memoria(sizeof(list_node));
call    0 returned 100%
      316:  395:    list_node* end = (list_node*)lat_asignar_memoria(sizeof(list_node));
call    0 returned 100%
      316:  396:    start->prev = NULL;
      316:  397:    start->next = end;
      316:  398:    start->data = NULL;
      316:  399:    end->prev = start;
      316:  400:    end->next = NULL;
      316:  401:    end->data = NULL;
      316:  402:    return start;
        -:  403:}
        -:  404:
        -:  405:/*list_node* lat_crear_lista()
        -:  406:{
        -:  407:    list_node* nodo = (list_node*)lat_asignar_memoria(sizeof(list_node));    
        -:  408:    nodo->prev = NULL;
        -:  409:    nodo->next = NULL;
        -:  410:    nodo->data = NULL;    
        -:  411:    return nodo;
        -:  412:}*/
        -:  413:
        -:  414:
function insert_list called 130 returned 100% blocks executed 100%
      130:  415:void insert_list(list_node* l, void* data)
        -:  416:{
      539:  417:    list_node* ins = (list_node*)lat_asignar_memoria(sizeof(list_node));
call    0 returned 100%
call    1 returned 100%
      539:  418:    ins->data = data;
      539:  419:    ins->next = l->next;
      539:  420:    l->next = ins;
      539:  421:    ins->prev = l;
      130:  422:}
        -:  423:
        -:  424:/*
        -:  425:void insert_list(list_node* l, void* data)
        -:  426:{
        -:  427:    list_node *curr = l;
        -:  428:    while (curr->next != NULL){
        -:  429:        curr = curr->next;
        -:  430:    }
        -:  431:    curr->data = data;
        -:  432:    curr->next = (list_node*)lat_asignar_memoria(sizeof(list_node));    
        -:  433:    curr->next->data = NULL;
        -:  434:    curr->next->prev = curr;
        -:  435:    curr->next->next = NULL;
        -:  436:    
        -:  437:}*/
        -:  438:
function remove_list called 0 returned 0% blocks executed 0%
    #####:  439:void remove_list(list_node* l, void* data)
        -:  440:{
        -:  441:    list_node* c;
        -:  442:    lat_objeto *find = (lat_objeto*)data;
    #####:  443:    for (c = l; c->next != NULL; c = c->next)
branch  0 never executed
branch  1 never executed
        -:  444:    {
    #####:  445:        lat_objeto *curr = c->data;
    #####:  446:        if(curr){
branch  0 never executed
branch  1 never executed
    #####:  447:            if (curr->data.i == find->data.i)
branch  0 never executed
branch  1 never executed
        -:  448:            {
        -:  449:                //printf("eliminar :: anterior:%p\tactual:%p\tsiguiente:%p\n", c->prev, c, c->next);
        -:  450:                //c->prev->next = c->next;
        -:  451:                //c->next->prev = c->prev;
    #####:  452:                c->prev->next = c->next;
        -:  453:                //c->next->prev = c;
    #####:  454:                return;
        -:  455:            }
        -:  456:        }
        -:  457:    }
        -:  458:}
        -:  459:
function length_list called 0 returned 0% blocks executed 0%
    #####:  460:int length_list(list_node* l)
        -:  461:{
        -:  462:    int a = 0;
        -:  463:    list_node* c;
    #####:  464:    for (c = l; c->next != NULL; c = c->next)
branch  0 never executed
branch  1 never executed
        -:  465:    {
    #####:  466:        if (c->data != NULL)
branch  0 never executed
branch  1 never executed
        -:  467:        {
    #####:  468:            a++;
        -:  469:        }
        -:  470:    }
    #####:  471:    return a;
        -:  472:}
        -:  473:
function find_list called 0 returned 0% blocks executed 0%
    #####:  474:int find_list(list_node* l, void* data)
        -:  475:{
        -:  476:    list_node* c;
    #####:  477:    for (c = l; c->next != NULL; c = c->next)
branch  0 never executed
branch  1 never executed
        -:  478:    {
    #####:  479:        if (c->data == data)
branch  0 never executed
branch  1 never executed
        -:  480:        {
        -:  481:            return 1;
        -:  482:        }
        -:  483:    }
        -:  484:    return 0;
        -:  485:}
        -:  486:
function make_hash_map called 1 returned 100% blocks executed 100%
        1:  487:hash_map* make_hash_map()
        -:  488:{
        5:  489:    hash_map* ret = (hash_map*)lat_asignar_memoria(sizeof(hash_map));
call    0 returned 100%
call    1 returned 100%
        -:  490:    int c;
     1281:  491:    for (c = 0; c < 256; c++)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
branch  3 taken 1% (fallthrough)
        -:  492:    {
     1280:  493:        ret->buckets[c] = NULL;
        -:  494:    }
        1:  495:    return ret;
        -:  496:}
        -:  497:
function hash called 0 returned 0% blocks executed 0%
    #####:  498:int hash(char* key)
        -:  499:{
        -:  500:    int h = 5381;
        -:  501:
        -:  502:    unsigned char c;
     4096:  503:    for (c = *key; c != '\0'; c = *++key)
branch  0 taken 88%
branch  1 taken 12% (fallthrough)
branch  2 taken 75%
branch  3 taken 25% (fallthrough)
branch  4 never executed
branch  5 never executed
     3528:  504:        h = h * 33 + c;
        -:  505:
      568:  506:    return abs(h % 256);
        -:  507:}
        -:  508:
function get_hash called 153 returned 100% blocks executed 100%
      153:  509:void* get_hash(hash_map* m, char* key)
        -:  510:{
      153:  511:    list_node* cur = m->buckets[hash(key)];
      153:  512:    if (cur == NULL)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  513:        return NULL;
      388:  514:    for (; cur->next != NULL; cur = cur->next)
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
        -:  515:    {
      388:  516:        if (cur->data != NULL)
branch  0 taken 61% (fallthrough)
branch  1 taken 39%
        -:  517:        {
      235:  518:            if (strcmp(key, ((hash_val *)cur->data)->key) == 0)
branch  0 taken 65% (fallthrough)
branch  1 taken 35%
        -:  519:            {
      153:  520:                return ((hash_val *)cur->data)->val;
        -:  521:            }
        -:  522:        }
        -:  523:    }
        -:  524:    return NULL;
        -:  525:}
        -:  526:
function set_hash called 415 returned 100% blocks executed 100%
      415:  527:void set_hash(hash_map *m, char *key, void *val)
        -:  528:{
      415:  529:    hash_val *hv = (hash_val *)lat_asignar_memoria(sizeof(hash_val));
call    0 returned 100%
      415:  530:    strncpy(hv->key, key, (strlen(key)+1));
      415:  531:    hv->val = val;
        -:  532:    int hk = hash(key);
      415:  533:    if (m->buckets[hk] == NULL)
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
        -:  534:    {
      312:  535:        m->buckets[hk] = lat_crear_lista();
call    0 returned 100%
        -:  536:    }
        -:  537:    else
        -:  538:    {
        -:  539:        list_node *c;
      337:  540:        for (c = m->buckets[hk]; c->next != NULL; c = c->next)
branch  0 taken 71%
branch  1 taken 29% (fallthrough)
        -:  541:        {
      240:  542:            if (c->data != NULL)
branch  0 taken 57% (fallthrough)
branch  1 taken 43%
        -:  543:            {
      137:  544:                if (strcmp(((hash_val *)c->data)->key, key) == 0)
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
        -:  545:                {
        6:  546:                    free(c->data);
        6:  547:                    c->data = (void *)hv;
      421:  548:                    return;
        -:  549:                }
        -:  550:            }
        -:  551:        }
        -:  552:    }
      409:  553:    insert_list(m->buckets[hk], (void *)hv);
        -:  554:}
        -:  555:
function copy_hash called 4 returned 100% blocks executed 100%
        4:  556:hash_map *copy_hash(hash_map *m)
        -:  557:{
        -:  558:    hash_map *ret = make_hash_map();
        -:  559:    int i;
     1024:  560:    for (i = 0; i < 256; i++)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:  561:    {
     1024:  562:        list_node *c = m->buckets[i];
     1024:  563:        if (c != NULL)
branch  0 taken 24% (fallthrough)
branch  1 taken 76%
        -:  564:        {
      563:  565:            for (; c->next != NULL; c = c->next)
branch  0 taken 70%
branch  1 taken 30% (fallthrough)
        -:  566:            {
      563:  567:                if (c->data != NULL)
branch  0 taken 57% (fallthrough)
branch  1 taken 43%
        -:  568:                {
      320:  569:                    set_hash(ret, ((hash_val *)c->data)->key, ((hash_val *)c->data)->val);
call    0 returned 100%
        -:  570:                }
        -:  571:            }
        -:  572:        }
        -:  573:    }
        4:  574:    return ret;
        -:  575:}
        -:  576:
function legible called 0 returned 0% blocks executed 0%
    #####:  577:bool legible(const char *archivo)
        -:  578:{
    #####:  579:    FILE *f = fopen(archivo, "r");
call    0 never executed
    #####:  580:    if(f == NULL)
branch  0 never executed
branch  1 never executed
        -:  581:    {
        -:  582:        return false;
        -:  583:    }
    #####:  584:    fclose(f);
call    0 never executed
    #####:  585:    return true;
        -:  586:}
