        -:    0:Source:/home/latino/src/latino/src/ast.c
        -:    0:Programs:13
        -:    1:/*
        -:    2:The MIT License (MIT)
        -:    3:
        -:    4:Copyright (c) 2015 - Latino
        -:    5:
        -:    6:Permission is hereby granted, free of charge, to any person obtaining a copy
        -:    7:of this software and associated documentation files (the "Software"), to deal
        -:    8:in the Software without restriction, including without limitation the rights
        -:    9:to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        -:   10:copies of the Software, and to permit persons to whom the Software is
        -:   11:furnished to do so, subject to the following conditions:
        -:   12:
        -:   13:The above copyright notice and this permission notice shall be included in
        -:   14:all copies or substantial portions of the Software.
        -:   15:
        -:   16:THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        -:   17:IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        -:   18:FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        -:   19:AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        -:   20:LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        -:   21:OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
        -:   22:THE SOFTWARE.
        -:   23:*/
        -:   24:#include <stdbool.h>
        -:   25:#include "latino.h"
        -:   26:#include "ast.h"
        -:   27:#include "utils.h"
        -:   28:#include "vm.h"
        -:   29:#include "libmem.h"
        -:   30:
        -:   31:#define dbc(I, A, B, M) bcode[i++] = lat_bc(I, A, B, M)
        -:   32:#define pn(vm, N) i = nodo_analizar(vm, N, bcode, i)
        -:   33:#define fdbc(I, A, B, M) funcion_bcode[fi++] = lat_bc(I, A, B, M)
        -:   34:#define fpn(vm, N) fi = nodo_analizar(vm, N, funcion_bcode, fi)
        -:   35:
function nodo_nuevo_operador called 23 returned 100% blocks executed 52%
       23:   36:ast *nodo_nuevo_operador(nodo_tipo nt, ast *l, ast *r)
        -:   37:{
       23:   38:    ast *a = (ast*)lat_asignar_memoria(sizeof(ast));
call    0 returned 100%
       23:   39:    switch (nt)
branch  0 taken 22%
branch  1 taken 22%
branch  2 taken 17%
branch  3 taken 22%
branch  4 taken 0%
branch  5 taken 0%
branch  6 taken 4%
branch  7 taken 0%
branch  8 taken 13%
branch  9 taken 0%
branch 10 taken 0%
branch 11 taken 0%
branch 12 taken 0%
branch 13 taken 0%
branch 14 taken 0%
branch 15 taken 0%
        -:   40:    {
        -:   41:    case NODO_SUMA:
        -:   42:    {
        5:   43:        a->l = nodo_nuevo_identificador("+", 1, 1);
call    0 returned 100%
        -:   44:    }
        5:   45:    break;
        -:   46:    case NODO_MENOS_UNARIO:
        -:   47:    case NODO_RESTA:
        -:   48:    {
        5:   49:        a->l = nodo_nuevo_identificador("-", 1, 1);
call    0 returned 100%
        -:   50:    }
        5:   51:    break;
        -:   52:    case NODO_MULTIPLICACION:
        -:   53:    {
        4:   54:        a->l = nodo_nuevo_identificador("*", 1, 1);
call    0 returned 100%
        -:   55:    }
        4:   56:    break;
        -:   57:    case NODO_DIVISION:
        -:   58:    {
        5:   59:        a->l = nodo_nuevo_identificador("/", 1, 1);
call    0 returned 100%
        -:   60:    }
        5:   61:    break;
        -:   62:    case NODO_MODULO:
        -:   63:    {
    #####:   64:        a->l = nodo_nuevo_identificador("%", 1, 1);
call    0 never executed
        -:   65:    }
    #####:   66:    break;
        -:   67:    case NODO_MAYOR_IGUAL:
        -:   68:    {
    #####:   69:        a->l = nodo_nuevo_identificador(">=", 1, 1);
call    0 never executed
        -:   70:    }
    #####:   71:    break;
        -:   72:    case NODO_MAYOR_QUE:
        -:   73:    {
        1:   74:        a->l = nodo_nuevo_identificador(">", 1, 1);
call    0 returned 100%
        -:   75:    }
        1:   76:    break;
        -:   77:    case NODO_MENOR_IGUAL:
        -:   78:    {
    #####:   79:        a->l = nodo_nuevo_identificador("<=", 1, 1);
call    0 never executed
        -:   80:    }
    #####:   81:    break;
        -:   82:    case NODO_MENOR_QUE:
        -:   83:    {
        3:   84:        a->l = nodo_nuevo_identificador("<", 1, 1);
call    0 returned 100%
        -:   85:    }
        3:   86:    break;
        -:   87:    case NODO_DESIGUALDAD:
        -:   88:    {
    #####:   89:        a->l = nodo_nuevo_identificador("!=", 1, 1);
call    0 never executed
        -:   90:    }
    #####:   91:    break;
        -:   92:    case NODO_IGUALDAD:
        -:   93:    {
    #####:   94:        a->l = nodo_nuevo_identificador("==", 1, 1);
call    0 never executed
        -:   95:    }
    #####:   96:    break;
        -:   97:    case NODO_NEGACION:
        -:   98:    {
    #####:   99:        a->l = nodo_nuevo_identificador("!", 1, 1);
call    0 never executed
        -:  100:    }
    #####:  101:    break;
        -:  102:    case NODO_Y:
        -:  103:    {
    #####:  104:        a->l = nodo_nuevo_identificador("&&", 1, 1);
call    0 never executed
        -:  105:    }
    #####:  106:    break;
        -:  107:    case NODO_O:
        -:  108:    {
    #####:  109:        a->l = nodo_nuevo_identificador("||", 1, 1);
call    0 never executed
        -:  110:    }
    #####:  111:    break;
        -:  112:    case NODO_CONCATENAR:
        -:  113:    {
    #####:  114:        a->l = nodo_nuevo_identificador(".", 1, 1);
call    0 never executed
        -:  115:    }
    #####:  116:    break;
        -:  117:    default:
        -:  118:        break;
        -:  119:    }
       23:  120:    if (nt == NODO_MENOS_UNARIO)
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
        -:  121:    {
        2:  122:        a->r = nodo_nuevo(NODO_FUNCION_ARGUMENTOS, nodo_nuevo_entero(0, 1, 1), l);
call    0 returned 100%
        -:  123:    }
       22:  124:    else if (nt == NODO_NEGACION)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  125:    {
    #####:  126:        a->r = nodo_nuevo(NODO_FUNCION_ARGUMENTOS, NULL, l);
        -:  127:    }
        -:  128:    else
        -:  129:    {
       22:  130:        a->r = nodo_nuevo(NODO_FUNCION_ARGUMENTOS, l, r);
        -:  131:    }
       23:  132:    a->tipo = NODO_FUNCION_LLAMADA;
       23:  133:    a->valor = NULL;
       23:  134:    return a;
        -:  135:}
        -:  136:
function nodo_nuevo called 150 returned 100% blocks executed 100%
      150:  137:ast *nodo_nuevo(nodo_tipo nt, ast *l, ast *r)
        -:  138:{
      176:  139:    ast *a = (ast*)lat_asignar_memoria(sizeof(ast));
call    0 returned 100%
call    1 never executed
call    2 returned 100%
call    3 returned 100%
call    4 never executed
call    5 returned 100%
      176:  140:    a->tipo = nt;
      176:  141:    a->l = l;
      176:  142:    a->r = r;
      176:  143:    a->valor = NULL;
      150:  144:    return a;
        -:  145:}
        -:  146:
function nodo_nuevo_entero called 15 returned 100% blocks executed 100%
       15:  147:ast *nodo_nuevo_entero(long i, int num_linea, int num_columna)
        -:  148:{
       15:  149:    ast *a = (ast*)lat_asignar_memoria(sizeof(ast));
call    0 returned 100%
       15:  150:    a->tipo = NODO_ENTERO;
       15:  151:    nodo_valor *val = (nodo_valor*)lat_asignar_memoria(sizeof(nodo_valor));
call    0 returned 100%
       15:  152:    val->t = VALOR_ENTERO;
       15:  153:    val->v.i = i;
       15:  154:    a->valor = val;
       15:  155:    a->valor->es_constante = false;
       15:  156:    a->valor->num_linea = num_linea;
       15:  157:    a->valor->num_columna = num_columna;
       15:  158:    return a;
        -:  159:}
        -:  160:
function nodo_nuevo_decimal called 6 returned 100% blocks executed 100%
        6:  161:ast *nodo_nuevo_decimal(double d, int num_linea, int num_columna)
        -:  162:{
        6:  163:    ast *a = (ast*)lat_asignar_memoria(sizeof(ast));
call    0 returned 100%
        6:  164:    a->tipo = NODO_DECIMAL;
        6:  165:    nodo_valor *val = (nodo_valor*)lat_asignar_memoria(sizeof(nodo_valor));
call    0 returned 100%
        6:  166:    val->t = VALOR_DECIMAL;
        6:  167:    val->v.d = d;
        6:  168:    a->valor = val;
        6:  169:    a->valor->es_constante = false;
        6:  170:    a->valor->num_linea = num_linea;
        6:  171:    a->valor->num_columna = num_columna;
        6:  172:    return a;
        -:  173:}
        -:  174:
function nodo_nuevo_logico called 1 returned 100% blocks executed 100%
        1:  175:ast *nodo_nuevo_logico(int b, int num_linea, int num_columna)
        -:  176:{
        1:  177:    ast *a = (ast*)lat_asignar_memoria(sizeof(ast));
call    0 returned 100%
        1:  178:    a->tipo = NODO_LOGICO;
        1:  179:    nodo_valor *val = (nodo_valor*)lat_asignar_memoria(sizeof(nodo_valor));
call    0 returned 100%
        1:  180:    val->t = VALOR_LOGICO;
        1:  181:    val->v.b = b;
        1:  182:    a->valor = val;
        1:  183:    a->valor->es_constante = false;
        1:  184:    a->valor->num_linea = num_linea;
        1:  185:    a->valor->num_columna = num_columna;
        1:  186:    return a;
        -:  187:}
        -:  188:
function nodo_nuevo_literal called 2 returned 100% blocks executed 100%
        2:  189:ast *nodo_nuevo_literal(char *c, int num_linea, int num_columna)
        -:  190:{
        2:  191:    ast *a = (ast*)lat_asignar_memoria(sizeof(ast));
call    0 returned 100%
        2:  192:    a->tipo = NODO_LITERAL;
        2:  193:    nodo_valor *val = (nodo_valor*)lat_asignar_memoria(sizeof(nodo_valor));
call    0 returned 100%
        2:  194:    val->t = VALOR_LITERAL;
        2:  195:    a->valor = val;
        2:  196:    a->valor->v.c = parse_string(c, strlen(c));
call    0 returned 100%
        2:  197:    a->valor->es_constante = false;
        2:  198:    a->valor->num_linea = num_linea;
        2:  199:    a->valor->num_columna = num_columna;
        2:  200:    return a;
        -:  201:}
        -:  202:
function nodo_nuevo_cadena called 10 returned 100% blocks executed 100%
       10:  203:ast *nodo_nuevo_cadena(const char *s, int num_linea, int num_columna)
        -:  204:{
       10:  205:    ast *a = (ast*)lat_asignar_memoria(sizeof(ast));
call    0 returned 100%
       10:  206:    a->tipo = NODO_CADENA;
       10:  207:    nodo_valor *val = (nodo_valor*)lat_asignar_memoria(sizeof(nodo_valor));
call    0 returned 100%
       10:  208:    val->t = VALOR_CADENA;
       10:  209:    val->v.s = parse_string(s, strlen(s));
call    0 returned 100%
       10:  210:    a->valor = val;
       10:  211:    a->valor->es_constante = false;
       10:  212:    a->valor->num_linea = num_linea;
       10:  213:    a->valor->num_columna = num_columna;
       10:  214:    return a;
        -:  215:}
        -:  216:
function nodo_nuevo_constante called 1 returned 100% blocks executed 100%
        1:  217:ast *nodo_nuevo_constante(char *s, int num_linea, int num_columna)
        -:  218:{
        1:  219:    ast *a = (ast*)lat_asignar_memoria(sizeof(ast));
call    0 returned 100%
        1:  220:    a->tipo = NODO_IDENTIFICADOR;
        1:  221:    nodo_valor *val = (nodo_valor*)lat_asignar_memoria(sizeof(nodo_valor));
call    0 returned 100%
        1:  222:    val->t = VALOR_CADENA;
        1:  223:    val->v.s = strdup0(s);
call    0 returned 100%
        1:  224:    a->valor = val;
        1:  225:    a->valor->es_constante = true;
        1:  226:    a->valor->num_linea = num_linea;
        1:  227:    a->valor->num_columna = num_columna;
        1:  228:    return a;
        -:  229:}
        -:  230:
function nodo_nuevo_identificador called 128 returned 100% blocks executed 100%
      128:  231:ast *nodo_nuevo_identificador(const char *s, int num_linea, int num_columna)
        -:  232:{
      128:  233:    ast *a = (ast*)lat_asignar_memoria(sizeof(ast));
call    0 returned 100%
      128:  234:    a->tipo = NODO_IDENTIFICADOR;
      128:  235:    nodo_valor *val = (nodo_valor*)lat_asignar_memoria(sizeof(nodo_valor));
call    0 returned 100%
      128:  236:    val->t = VALOR_CADENA;
      128:  237:    val->v.s = strdup0(s);
call    0 returned 100%
      128:  238:    a->valor = val;
      128:  239:    a->valor->es_constante = false;
      128:  240:    a->valor->num_linea = num_linea;
      128:  241:    a->valor->num_columna = num_columna;
      128:  242:    return a;
        -:  243:}
        -:  244:
function nodo_nuevo_asignacion called 11 returned 100% blocks executed 100%
       11:  245:ast *nodo_nuevo_asignacion(ast *v, ast *s)
        -:  246:{
       11:  247:    ast *a = (ast*)lat_asignar_memoria(sizeof(ast));
call    0 returned 100%
       11:  248:    a->tipo = NODO_ASIGNACION;
       11:  249:    a->l = v;
       11:  250:    a->r = s;
       11:  251:    a->valor = NULL;
       11:  252:    return a;
        -:  253:}
        -:  254:
function nodo_nuevo_asignacion_lista_elem called 0 returned 0% blocks executed 0%
    #####:  255:ast *nodo_nuevo_asignacion_lista_elem(ast *exp, ast *id, ast *pos)
        -:  256:{
    #####:  257:    nodo_lista_elem *a = (nodo_lista_elem*)lat_asignar_memoria(sizeof(nodo_lista_elem));
call    0 never executed
    #####:  258:    a->tipo = NODO_LISTA_ASIGNAR_ELEMENTO;
    #####:  259:    a->exp = exp;
    #####:  260:    a->id = id;
    #####:  261:    a->pos = pos;
    #####:  262:    return (ast *)a;
        -:  263:}
        -:  264:
function nodo_nuevo_asignacion_dicc_elem called 0 returned 0% blocks executed 0%
    #####:  265:ast *nodo_nuevo_asignacion_dicc_elem(ast *exp, ast *id, ast *llave)
        -:  266:{
    #####:  267:    nodo_lista_elem *a = (nodo_lista_elem*)lat_asignar_memoria(sizeof(nodo_lista_elem));
call    0 never executed
    #####:  268:    a->tipo = NODO_DICC_ASIGNAR_ELEMENTO;
    #####:  269:    a->exp = exp;
    #####:  270:    a->id = id;
    #####:  271:    a->pos = llave;
    #####:  272:    return (ast *)a;
        -:  273:}
        -:  274:
function nodo_nuevo_si called 3 returned 100% blocks executed 100%
        3:  275:ast *nodo_nuevo_si(ast *cond, ast *th, ast *el)
        -:  276:{
        3:  277:    nodo_si *a = (nodo_si*)lat_asignar_memoria(sizeof(nodo_si));
call    0 returned 100%
        3:  278:    a->tipo = NODO_SI;
        3:  279:    a->cond = cond;
        3:  280:    a->th = th;
        3:  281:    a->el = el;
        3:  282:    return (ast *)a;
        -:  283:}
        -:  284:
function nodo_nuevo_mientras called 1 returned 100% blocks executed 100%
        1:  285:ast *nodo_nuevo_mientras(ast *cond, ast *stmts)
        -:  286:{
        1:  287:    ast *a = (ast*)lat_asignar_memoria(sizeof(ast));
call    0 never executed
call    1 returned 100%
        1:  288:    a->tipo = NODO_MIENTRAS;
        1:  289:    a->l = cond;
        1:  290:    a->r = stmts;
        1:  291:    a->valor = NULL;
        1:  292:    return a;
        -:  293:}
        -:  294:
function nodo_nuevo_hacer called 0 returned 0% blocks executed 0%
    #####:  295:ast *nodo_nuevo_hacer(ast *cond, ast *stmts)
        -:  296:{
    #####:  297:    ast *a = (ast*)lat_asignar_memoria(sizeof(ast));
call    0 never executed
    #####:  298:    a->tipo = NODO_HACER;
    #####:  299:    a->l = cond;
    #####:  300:    a->r = stmts;
    #####:  301:    a->valor = NULL;
    #####:  302:    return a;
        -:  303:}
        -:  304:
function nodo_nuevo_desde called 0 returned 0% blocks executed 0%
    #####:  305:ast *nodo_nuevo_desde(ast *dec, ast *cond, ast *inc, ast *stmts)
        -:  306:{
    #####:  307:    ast *a = (ast*)lat_asignar_memoria(sizeof(ast));
call    0 never executed
    #####:  308:    a->tipo = NODO_BLOQUE;
    #####:  309:    a->l = nodo_nuevo_mientras(cond, nodo_nuevo(NODO_BLOQUE, inc, stmts));
    #####:  310:    a->r = dec;
    #####:  311:    a->valor = NULL;
    #####:  312:    return a;
        -:  313:}
        -:  314:
function nodo_nuevo_funcion called 3 returned 100% blocks executed 100%
        3:  315:ast *nodo_nuevo_funcion(ast *s, ast *syms, ast *func)
        -:  316:{
        3:  317:    ast *a = (ast*)lat_asignar_memoria(sizeof(ast));
call    0 returned 100%
        3:  318:    a->tipo = NODO_ASIGNACION;
        3:  319:    a->l = nodo_nuevo(NODO_FUNCION_USUARIO, syms, func);
        3:  320:    a->r = s;
        3:  321:    a->valor = NULL;
        3:  322:    return a;
        -:  323:}
        -:  324:
function nodo_nuevo_incluir called 0 returned 0% blocks executed 0%
    #####:  325:ast* nodo_nuevo_incluir(ast* ruta)
        -:  326:{
    #####:  327:    ast *a = (ast*)lat_asignar_memoria(sizeof(ast));
call    0 never executed
    #####:  328:    a->tipo = NODO_INCLUIR;
    #####:  329:    a->l = ruta;
    #####:  330:    a->r = NULL;
    #####:  331:    a->valor = NULL;
    #####:  332:    return a;
        -:  333:}
        -:  334:
function nodo_liberar called 48 returned 100% blocks executed 100%
       48:  335:void nodo_liberar(ast *a)
        -:  336:{
       96:  337:    if (a)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  338:    {
       96:  339:        switch (a->tipo)
branch  0 taken 50%
branch  1 taken 50%
        -:  340:        {
        -:  341:        case NODO_BLOQUE:
        -:  342:        case NODO_LISTA_AGREGAR_ELEMENTO:
       48:  343:            if (a->r)
branch  0 taken 98% (fallthrough)
branch  1 taken 2%
       47:  344:                nodo_liberar(a->r);
call    0 returned 100%
       48:  345:            if (a->l)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  346:                nodo_liberar(a->l);
        -:  347:            break;
        -:  348:        default:
       48:  349:            if (a->tipo)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       48:  350:                lat_liberar_memoria(a->valor);
call    0 returned 100%
       48:  351:            lat_liberar_memoria(a);
call    0 returned 100%
       48:  352:            break;
        -:  353:        }
        -:  354:    }
       48:  355:}
        -:  356:
function nodo_analizar_arbol called 1 returned 100% blocks executed 100%
        1:  357:lat_objeto *nodo_analizar_arbol(lat_vm *vm, ast *tree)
        -:  358:{
        1:  359:    lat_bytecode *bcode = (lat_bytecode *)lat_asignar_memoria(sizeof(lat_bytecode) * MAX_BYTECODE_FUNCTION);
call    0 returned 100%
        1:  360:    int i = nodo_analizar(vm, tree, bcode, 0);
call    0 returned 100%
        1:  361:    dbc(OP_END, 0, 0, NULL);
call    0 returned 100%
        1:  362:    nodo_liberar(tree);
call    0 returned 100%
        1:  363:    return lat_definir_funcion(vm, bcode);
call    0 returned 100%
        -:  364:}
        -:  365:
        -:  366:int nested = -1;
        -:  367:
function nodo_analizar called 360 returned 100% blocks executed 49%
      360:  368:int nodo_analizar(lat_vm *vm, ast *node, lat_bytecode *bcode, int i)
        -:  369:{
        -:  370:    int temp[8] = {0};
        -:  371:    lat_bytecode *funcion_bcode = NULL;
        -:  372:    int fi = 0;
      360:  373:    switch (node->tipo)
branch  0 taken 0%
branch  1 taken 16%
branch  2 taken 30%
branch  3 taken 4%
branch  4 taken 1%
branch  5 taken 0%
branch  6 taken 1%
branch  7 taken 4%
branch  8 taken 2%
branch  9 taken 3%
branch 10 taken 1%
branch 11 taken 1%
branch 12 taken 1%
branch 13 taken 0%
branch 14 taken 17%
branch 15 taken 1%
branch 16 taken 18%
branch 17 taken 2%
branch 18 taken 1%
branch 19 taken 0%
branch 20 taken 0%
branch 21 taken 0%
branch 22 taken 0%
branch 23 taken 0%
branch 24 taken 0%
branch 25 taken 0%
branch 26 taken 0%
branch 27 taken 0%
branch 28 taken 0%
branch 29 taken 0%
        -:  374:    {
        -:  375:    case NODO_INCLUIR:
        -:  376:    {
        -:  377:        //TODO: Incluir rutas con punto ej. incluir "lib.modulos.myModulo"
    #####:  378:        char* archivo = node->l->valor->v.s;
    #####:  379:        lat_objeto* mod = lat_cadena_nueva(vm, archivo);
call    0 never executed
    #####:  380:        if(!find_list(vm->modulos, (void*)mod))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  381:        {
        -:  382:            //encontrar el modulo en la ruta actual
        -:  383:            char dir_actual[MAX_PATH_LENGTH];
    #####:  384:            getcwd(dir_actual, sizeof(dir_actual));
call    0 never executed
    #####:  385:            strcat(dir_actual, PATH_SEP);
    #####:  386:            strcat(dir_actual, archivo);
    #####:  387:            if(!endsWith(dir_actual, ".lat"))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  388:            {
    #####:  389:                strcat(dir_actual, ".lat");
        -:  390:            }
    #####:  391:            if(legible(dir_actual))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  392:            {
    #####:  393:                insert_list(vm->modulos, mod);
call    0 never executed
    #####:  394:                pn(vm, lat_analizar_archivo(vm, dir_actual));
call    0 never executed
call    1 never executed
        -:  395:            }
        -:  396:            else
        -:  397:            {
        -:  398:                //sino existe buscar en el path_home de latino/lib
    #####:  399:                char* latino_lib = getenv("LATINO_LIB");
call    0 never executed
    #####:  400:                if(latino_lib != NULL)
branch  0 never executed
branch  1 never executed
        -:  401:                {
    #####:  402:                    strcat(latino_lib, PATH_SEP);
    #####:  403:                    strcat(latino_lib, archivo);
    #####:  404:                    if(!endsWith(latino_lib, ".lat"))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  405:                    {
    #####:  406:                        strcat(latino_lib, ".lat");
        -:  407:                    }
    #####:  408:                    if(legible(latino_lib))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  409:                    {
    #####:  410:                        insert_list(vm->modulos, mod);
call    0 never executed
    #####:  411:                        pn(vm, lat_analizar_archivo(vm, latino_lib));
call    0 never executed
call    1 never executed
        -:  412:                    }
        -:  413:                }
        -:  414:            }
        -:  415:        }
        -:  416:        //return NULL;
        -:  417:    }
        -:  418:    break;
        -:  419:    case NODO_BLOQUE:
        -:  420:    {
       59:  421:        if (node->r)
branch  0 taken 81% (fallthrough)
branch  1 taken 19%
        -:  422:        {
       48:  423:            pn(vm, node->r);
call    0 returned 100%
        -:  424:        }
       59:  425:        if (node->l)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  426:        {
       59:  427:            pn(vm, node->l);
call    0 returned 100%
        -:  428:        }
        -:  429:    }
        -:  430:    break;
        -:  431:    case NODO_IDENTIFICADOR: /*GET*/
        -:  432:    {
      109:  433:        dbc(OP_LOCALNS, 1, 0, NULL);
call    0 returned 100%
      109:  434:        lat_objeto *ret = lat_cadena_nueva(vm, node->valor->v.s);
call    0 returned 100%
      109:  435:        dbc(OP_STORESTR, 2, 0, ret);
call    0 returned 100%
      109:  436:        dbc(OP_GET, 2, 1, NULL);
call    0 returned 100%
      109:  437:        dbc(OP_MOV, 255, 2, NULL);
call    0 returned 100%
        -:  438:#if DEBUG_VM
        -:  439:        printf("LOCALNS R1\n");
        -:  440:        printf("STORESTR R2 %s\n", ret->data.str);
        -:  441:        printf("GET R2 R1\n");
        -:  442:        printf("MOV R255 R2\n");
        -:  443:#endif
        -:  444:    }
      109:  445:    break;
        -:  446:    case NODO_ASIGNACION: /*SET*/
        -:  447:    {
       14:  448:        pn(vm, node->l);
call    0 returned 100%
       14:  449:        dbc(OP_PUSH, 255, 0, NULL);
call    0 returned 100%
       14:  450:        lat_objeto *ret = lat_cadena_nueva(vm, node->r->valor->v.s);
call    0 returned 100%
       14:  451:        if (ret->num_declared < 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  452:        {
    #####:  453:            ret->num_declared = 0;
        -:  454:        }
       14:  455:        ret->es_constante = node->r->valor->es_constante;
       14:  456:        ret->num_declared++;
       14:  457:        if (ret->es_constante && ret->num_declared > 1)
branch  0 taken 7% (fallthrough)
branch  1 taken 93%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  458:        {
    #####:  459:            lat_registrar_error("Linea %d: %s", (node->r->valor->num_linea + 1),  "Intento de asignar un nuevo valor a una constante ");
call    0 never executed
        -:  460:        }
       14:  461:        dbc(OP_LOCALNS, 1, 0, NULL);
call    0 returned 100%
       14:  462:        dbc(OP_POP, 255, 0, NULL);
call    0 returned 100%
       14:  463:        dbc(OP_SET, 255, 1, ret);
call    0 returned 100%
        -:  464:#if DEBUG_VM
        -:  465:        printf("PUSH R255 R0\n");
        -:  466:        printf("LOCALNS R1 R0\n");
        -:  467:        printf("POP R255 R0\n");
        -:  468:        printf("SET R255 R1\n");
        -:  469:#endif
        -:  470:    }
       14:  471:    break;
        -:  472:    case NODO_INCREMENTO:
        -:  473:    {
        1:  474:        pn(vm, node->l);
call    0 returned 100%
        1:  475:        dbc(OP_INC, 255, 0, NULL);
call    0 returned 100%
        -:  476:#if DEBUG_VM
        -:  477:        printf("INC R255 R0\n");
        -:  478:#endif
        -:  479:    }
        1:  480:    break;
        -:  481:    case NODO_DECREMENTO:
        -:  482:    {
    #####:  483:        pn(vm, node->l);
call    0 never executed
    #####:  484:        dbc(OP_DEC, 255, 0, NULL);
call    0 never executed
        -:  485:#if DEBUG_VM
        -:  486:        printf("DEC R255 R0\n");
        -:  487:#endif
        -:  488:    }
    #####:  489:    break;
        -:  490:    case NODO_LITERAL:
        -:  491:    {
        2:  492:        lat_objeto *ret = lat_literal_nuevo(vm, node->valor->v.c);
call    0 returned 100%
        2:  493:        dbc(OP_STORELIT, 255, 0, ret);
call    0 returned 100%
        -:  494:#if DEBUG_VM
        -:  495:        printf("STORECHAR R255 %s\n", ret->data.str);
        -:  496:#endif
        -:  497:    }
        2:  498:    break;
        -:  499:    case NODO_ENTERO:
        -:  500:    {
       15:  501:        lat_objeto *ret = lat_entero_nuevo(vm, node->valor->v.i);
call    0 returned 100%
       15:  502:        dbc(OP_STOREINT, 255, 0, ret);
call    0 returned 100%
        -:  503:#if DEBUG_VM
        -:  504:        printf("STOREINT R255 %ld\n", ret->data.i);
        -:  505:#endif
        -:  506:    }
       15:  507:    break;
        -:  508:    case NODO_DECIMAL:
        -:  509:    {
        6:  510:        lat_objeto *ret = lat_decimal_nuevo(vm, node->valor->v.d);
call    0 returned 100%
        6:  511:        dbc(OP_STOREDOUBLE, 255, 0, ret);
call    0 returned 100%
        -:  512:#if DEBUG_VM
        -:  513:        printf("OP_STOREDOUBLE R255 %.14g\n", ret->data.d);
        -:  514:#endif
        -:  515:    }
        6:  516:    break;
        -:  517:    case NODO_CADENA:
        -:  518:    {
       10:  519:        lat_objeto *ret = lat_cadena_nueva(vm, node->valor->v.s);
call    0 returned 100%
       10:  520:        dbc(OP_STORESTR, 255, 0, ret);
call    0 returned 100%
        -:  521:#if DEBUG_VM
        -:  522:        printf("STORESTR R255 %s\n", ret->data.str);
        -:  523:#endif
        -:  524:    }
       10:  525:    break;
        -:  526:    case NODO_LOGICO:
        -:  527:    {
        1:  528:        lat_objeto *ret = node->valor->v.b ? vm->objeto_cierto : vm->objeto_falso;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  529:        dbc(OP_STOREBOOL, 255, 0, ret);
call    0 returned 100%
        -:  530:#if DEBUG_VM
        -:  531:        printf("STOREBOOL R255 %i\n", ret->data.b);
        -:  532:#endif
        -:  533:    }
        1:  534:    break;
        -:  535:    case NODO_SI:
        -:  536:    {
        -:  537:        nodo_si *nIf = ((nodo_si *)node);
        3:  538:        pn(vm, nIf->cond);
call    0 returned 100%
        3:  539:        dbc(OP_MOV, 2, 255, NULL);
call    0 returned 100%
        3:  540:        dbc(OP_MOV, 3, 255, NULL);
call    0 returned 100%
        3:  541:        dbc(OP_NOT, 2, 0, NULL);
call    0 returned 100%
        -:  542:        temp[0] = i;
        3:  543:        dbc(OP_NOP, 0, 0, NULL);
call    0 returned 100%
        3:  544:        pn(vm, nIf->th);
call    0 returned 100%
        3:  545:        bcode[temp[0]] = lat_bc(OP_JMPIF, i, 2, NULL);
call    0 returned 100%
        -:  546:#if DEBUG_VM
        -:  547:        printf("MOV R2 R255\n");
        -:  548:        printf("MOV R3 R255\n");
        -:  549:        printf("NOT\n");
        -:  550:        printf("NOP R0 R0\n");
        -:  551:        printf("JMPIF R%i R2\n", i);
        -:  552:#endif
        3:  553:        if (nIf->el)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  554:        {
        -:  555:            temp[1] = i;
        3:  556:            dbc(OP_NOP, 0, 0, NULL);
call    0 returned 100%
        3:  557:            pn(vm, nIf->el);
call    0 returned 100%
        3:  558:            bcode[temp[1]] = lat_bc(OP_JMPIF, i, 3, NULL);
call    0 returned 100%
        -:  559:#if DEBUG_VM
        -:  560:            printf("NOP\n");
        -:  561:            printf("MOV R3 R255\n");
        -:  562:            printf("JMPIF R%i R3\n", i);
        -:  563:#endif
        -:  564:        }
        -:  565:    }
        -:  566:    break;
        -:  567:    case NODO_MIENTRAS:
        -:  568:    {
        -:  569:        temp[0] = i;
        1:  570:        pn(vm, node->l);
call    0 returned 100%
        1:  571:        dbc(OP_MOV, 2, 255, NULL);
call    0 returned 100%
        1:  572:        dbc(OP_NOT, 2, 0, NULL);
call    0 returned 100%
        -:  573:        temp[1] = i;
        1:  574:        dbc(OP_NOP, 0, 0, NULL);
call    0 returned 100%
        1:  575:        pn(vm, node->r);
call    0 returned 100%
        1:  576:        dbc(OP_JMP, temp[0], 0, NULL);
call    0 returned 100%
        1:  577:        bcode[temp[1]] = lat_bc(OP_JMPIF, i, 2, NULL);
call    0 returned 100%
        -:  578:#if DEBUG_VM
        -:  579:        printf("MOV R2 R255\n");
        -:  580:        printf("NOT R2 R0\n");
        -:  581:        printf("NOP\n");
        -:  582:        printf("JMP R%i\n", temp[0]);
        -:  583:        printf("JMPIF R%i R2\n", i);
        -:  584:#endif
        -:  585:    }
        1:  586:    break;
        -:  587:    case NODO_HACER:
        -:  588:    {
    #####:  589:        pn(vm, node->r);
call    0 never executed
        -:  590:        temp[0] = i;
    #####:  591:        pn(vm, node->l);
call    0 never executed
    #####:  592:        dbc(OP_MOV, 2, 255, NULL);
call    0 never executed
    #####:  593:        dbc(OP_NOT, 2, 0, NULL);
call    0 never executed
        -:  594:        temp[1] = i;
    #####:  595:        dbc(OP_NOP, 0, 0, NULL);
call    0 never executed
    #####:  596:        pn(vm, node->r);
call    0 never executed
    #####:  597:        dbc(OP_JMP, temp[0], 0, NULL);
call    0 never executed
    #####:  598:        bcode[temp[1]] = lat_bc(OP_JMPIF, i, 2, NULL);
call    0 never executed
        -:  599:#if DEBUG_VM
        -:  600:        printf("MOV R2 R255\n");
        -:  601:        printf("NOT R2 R0\n");
        -:  602:        printf("NOP\n");
        -:  603:        printf("JMP R%i\n", temp[0]);
        -:  604:        printf("JMPIF R%i R2\n", i);
        -:  605:#endif
        -:  606:    }
    #####:  607:    break;
        -:  608:    case NODO_FUNCION_LLAMADA:
        -:  609:    {
       61:  610:        if (node->r)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  611:        {
       61:  612:            pn(vm, node->r);
call    0 returned 100%
        -:  613:        }
       61:  614:        pn(vm, node->l);
call    0 returned 100%
       61:  615:        dbc(OP_CALL, 255, 0, NULL);
call    0 returned 100%
        -:  616:#if DEBUG_VM
        -:  617:        printf("CALL R255\n");
        -:  618:#endif
        -:  619:    }
       61:  620:    break;
        -:  621:    case NODO_RETORNO:
        -:  622:    {
        5:  623:        pn(vm, node->l);
call    0 returned 100%
        5:  624:        dbc(OP_END, 0, 0, NULL);
call    0 returned 100%
        -:  625:#if DEBUG_VM
        -:  626:        printf("END R255\n");
        -:  627:#endif
        -:  628:    }
        5:  629:    break;
        -:  630:    case NODO_FUNCION_ARGUMENTOS:
        -:  631:    {
       64:  632:        if (node->l)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  633:        {
       64:  634:            pn(vm, node->l);
call    0 returned 100%
       64:  635:            dbc(OP_PUSH, 255, 0, NULL);
call    0 returned 100%
        -:  636:#if DEBUG_VM
        -:  637:            printf("PUSH R255\n");
        -:  638:#endif
        -:  639:        }
       64:  640:        if (node->r)
branch  0 taken 41% (fallthrough)
branch  1 taken 59%
        -:  641:        {
       26:  642:            pn(vm, node->r);
call    0 returned 100%
        -:  643:            //Soporte para recursion NODO_FUNCION_LLAMADA
       26:  644:            if (node->r->valor || node->r->tipo == NODO_FUNCION_LLAMADA)
branch  0 taken 15% (fallthrough)
branch  1 taken 85%
branch  2 taken 25% (fallthrough)
branch  3 taken 75%
        -:  645:            {
       23:  646:                dbc(OP_PUSH, 255, 0, NULL);
call    0 returned 100%
        -:  647:#if DEBUG_VM
        -:  648:                printf("PUSH R255\n");
        -:  649:#endif
        -:  650:            }
        -:  651:        }
        -:  652:    }
        -:  653:    break;
        -:  654:    case NODO_LISTA_PARAMETROS:
        -:  655:    {
        6:  656:        if (node->l)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  657:        {
        6:  658:            dbc(OP_LOCALNS, 1, 0, NULL);
call    0 returned 100%
        6:  659:            dbc(OP_POP, 2, 0, NULL);
call    0 returned 100%
        6:  660:            lat_objeto *ret = lat_clonar_objeto(vm, lat_cadena_nueva(vm, node->l->valor->v.s));
call    0 returned 100%
call    1 returned 100%
        6:  661:            dbc(OP_SET, 2, 1, ret);
call    0 returned 100%
        -:  662:#if DEBUG_VM
        -:  663:            printf("LOCALNS R1\n");
        -:  664:            printf("POP R2\n");
        -:  665:            printf("SET R2 R1 %s\n", ret->data.str);
        -:  666:#endif
        -:  667:        }
        6:  668:        if (node->r)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  669:        {
        3:  670:            pn(vm, node->r);
call    0 returned 100%
        -:  671:        }
        -:  672:    }
        -:  673:    break;
        -:  674:    case NODO_FUNCION_USUARIO:
        -:  675:    {
        3:  676:        funcion_bcode =
call    0 returned 100%
        -:  677:            (lat_bytecode *)lat_asignar_memoria(sizeof(lat_bytecode) * MAX_BYTECODE_FUNCTION);
        -:  678:        fi = 0;
        3:  679:        if (node->l)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  680:        {
        3:  681:            fpn(vm, node->l);
call    0 returned 100%
        -:  682:        }
        3:  683:        fpn(vm, node->r);
call    0 returned 100%
        3:  684:        dbc(OP_FN, 255, 0, funcion_bcode);
call    0 returned 100%
        -:  685:#if DEBUG_VM
        -:  686:        printf("FN R255\n");
        -:  687:#endif
        -:  688:        funcion_bcode = NULL;
        -:  689:        fi = 0;
        -:  690:    }
        3:  691:    break;
        -:  692:    case NODO_LISTA:
        -:  693:    {
    #####:  694:        nested++;
    #####:  695:        dbc(OP_STORELIST, nested, 0, NULL);
call    0 never executed
        -:  696:#if DEBUG_VM
        -:  697:        printf("STORELIST R%i\n", nested);
        -:  698:#endif
    #####:  699:        if (node->l)
branch  0 never executed
branch  1 never executed
        -:  700:        {
    #####:  701:            pn(vm, node->l);
call    0 never executed
    #####:  702:            dbc(OP_MOV, 255, nested, NULL);
call    0 never executed
        -:  703:#if DEBUG_VM
        -:  704:            printf("MOV R255 R%i\n", nested);
        -:  705:#endif
        -:  706:        }
    #####:  707:        nested--;
        -:  708:    }
    #####:  709:    break;
        -:  710:    case NODO_LISTA_AGREGAR_ELEMENTO:
        -:  711:    {
    #####:  712:        if (node->l)
branch  0 never executed
branch  1 never executed
        -:  713:        {
    #####:  714:            pn(vm, node->l);
call    0 never executed
    #####:  715:            dbc(OP_PUSHLIST, nested, 255, NULL);
call    0 never executed
        -:  716:#if DEBUG_VM
        -:  717:            printf("PUSHLIST R%i R255\n", nested);
        -:  718:#endif
        -:  719:        }
    #####:  720:        if (node->r)
branch  0 never executed
branch  1 never executed
        -:  721:        {
    #####:  722:            pn(vm, node->r);
call    0 never executed
        -:  723:        }
        -:  724:    }
        -:  725:    break;
        -:  726:    case NODO_LISTA_ASIGNAR_ELEMENTO:
        -:  727:    {
        -:  728:        nodo_lista_elem *elem = ((nodo_lista_elem *)node);
    #####:  729:        if (elem->exp)
branch  0 never executed
branch  1 never executed
        -:  730:        {
    #####:  731:            pn(vm, elem->exp);
call    0 never executed
    #####:  732:            dbc(OP_MOV, 3, 255, NULL);
call    0 never executed
        -:  733:#if DEBUG_VM
        -:  734:            printf("MOV R3 R255\n");
        -:  735:#endif
        -:  736:        }
    #####:  737:        if(elem->id)
branch  0 never executed
branch  1 never executed
        -:  738:        {
    #####:  739:            pn(vm, elem->pos);
call    0 never executed
    #####:  740:            dbc(OP_MOV, 4, 255, NULL);
call    0 never executed
        -:  741:#if DEBUG_VM
        -:  742:            printf("MOV R4 R255\n");
        -:  743:#endif
    #####:  744:            pn(vm, elem->id);
call    0 never executed
    #####:  745:            dbc(OP_LISTSETITEM, 255, 3, (void *)4);
call    0 never executed
        -:  746:#if DEBUG_VM
        -:  747:            printf("LISTSETITEM R255 R3\n");
        -:  748:#endif
        -:  749:        }
        -:  750:    }
        -:  751:    break;
        -:  752:    case NODO_LISTA_OBTENER_ELEMENTO:
        -:  753:    {
    #####:  754:        if (node->l)
branch  0 never executed
branch  1 never executed
        -:  755:        {
    #####:  756:            pn(vm, node->l);
call    0 never executed
    #####:  757:            dbc(OP_MOV, 3, 255, NULL);
call    0 never executed
        -:  758:#if DEBUG_VM
        -:  759:            printf("MOV R3 R255\n");
        -:  760:#endif
        -:  761:        }
    #####:  762:        if (node->r)
branch  0 never executed
branch  1 never executed
        -:  763:        {
    #####:  764:            pn(vm, node->r);
call    0 never executed
    #####:  765:            dbc(OP_LISTGETITEM, 255, 3, NULL);
call    0 never executed
        -:  766:#if DEBUG_VM
        -:  767:            printf("LISTGETITEM R55 R3\n");
        -:  768:#endif
        -:  769:        }
        -:  770:    }
        -:  771:    break;
        -:  772:    case NODO_DICCIONARIO:
        -:  773:    {
    #####:  774:        nested++;
    #####:  775:        dbc(OP_STOREDICT, nested, 0, NULL);
call    0 never executed
        -:  776:#if DEBUG_VM
        -:  777:        printf("STOREDICT R%i\n", nested);
        -:  778:#endif
    #####:  779:        if (node->l)
branch  0 never executed
branch  1 never executed
        -:  780:        {
    #####:  781:            pn(vm, node->l);
call    0 never executed
    #####:  782:            dbc(OP_MOV, 255, nested, NULL);
call    0 never executed
        -:  783:#if DEBUG_VM
        -:  784:            printf("MOV R255 R%i\n", nested);
        -:  785:#endif
        -:  786:        }
    #####:  787:        nested--;
        -:  788:    }
    #####:  789:    break;
        -:  790:    case NODO_DICC_AGREGAR_ELEMENTO:
        -:  791:    {
    #####:  792:        if(node->l)
branch  0 never executed
branch  1 never executed
        -:  793:        {
    #####:  794:            pn(vm, node->l);
call    0 never executed
    #####:  795:            dbc(OP_PUSHDICT, nested, 255, NULL);
call    0 never executed
        -:  796:#if DEBUG_VM
        -:  797:            printf("PUSHDICT R%i R255\n", nested);
        -:  798:#endif
        -:  799:        }
    #####:  800:        if(node->r)
branch  0 never executed
branch  1 never executed
        -:  801:        {
    #####:  802:            pn(vm, node->r);
call    0 never executed
        -:  803:        }
        -:  804:    }
        -:  805:    break;
        -:  806:    case NODO_DICC_ELEMENTO:
        -:  807:    {
    #####:  808:        if(node->l){
branch  0 never executed
branch  1 never executed
    #####:  809:            pn(vm, node->l);
call    0 never executed
    #####:  810:            dbc(OP_PUSH, 255, 0, NULL);
call    0 never executed
        -:  811:            #if DEBUG_VM
        -:  812:                printf("PUSH R255\n");
        -:  813:            #endif
        -:  814:        }
    #####:  815:        if(node->r){
branch  0 never executed
branch  1 never executed
    #####:  816:            pn(vm, node->r);
call    0 never executed
    #####:  817:            dbc(OP_PUSH, 255, 0, NULL);
call    0 never executed
        -:  818:            #if DEBUG_VM
        -:  819:                printf("PUSH R255\n");
        -:  820:            #endif
        -:  821:        }
    #####:  822:        dbc(OP_PUSHDICTELEM, 0, 0, NULL);
call    0 never executed
        -:  823:        #if DEBUG_VM
        -:  824:            printf("OP_PUSHDICTELEM\n");
        -:  825:        #endif
        -:  826:    }
    #####:  827:    break;
        -:  828:    case NODO_DICC_ASIGNAR_ELEMENTO:
        -:  829:    {
        -:  830:        nodo_dicc_elem *elem = ((nodo_dicc_elem *)node);
    #####:  831:        if(elem->exp)
branch  0 never executed
branch  1 never executed
        -:  832:        {
    #####:  833:            pn(vm, elem->exp);
call    0 never executed
    #####:  834:            dbc(OP_MOV, 3, 255, NULL);
call    0 never executed
        -:  835:#if DEBUG_VM
        -:  836:            printf("MOV R3 R255\n");
        -:  837:#endif
        -:  838:        }
    #####:  839:        if(elem->id)
branch  0 never executed
branch  1 never executed
        -:  840:        {
    #####:  841:            pn(vm, elem->llave);
call    0 never executed
    #####:  842:            dbc(OP_MOV, 4, 255, NULL);
call    0 never executed
        -:  843:#if DEBUG_VM
        -:  844:            printf("MOV R4 R255\n");
        -:  845:#endif
    #####:  846:            pn(vm, elem->id);
call    0 never executed
    #####:  847:            dbc(OP_DICTSETITEM, 255, 3, (void*)4);
call    0 never executed
        -:  848:#if DEBUG_VM
        -:  849:            printf("DICTITEM R255 R3\n");
        -:  850:#endif
        -:  851:        }
        -:  852:    }
        -:  853:    break;
        -:  854:    case NODO_DICC_OBTENER_ELEMENTO:
        -:  855:    {
    #####:  856:        if(node->l){
branch  0 never executed
branch  1 never executed
    #####:  857:            pn(vm, node->l);
call    0 never executed
    #####:  858:            dbc(OP_MOV, 3, 255, NULL);
call    0 never executed
        -:  859:            #if DEBUG_VM
        -:  860:            printf("MOV R3 R255\n");
        -:  861:            #endif
        -:  862:        }
    #####:  863:        if(node->r){
branch  0 never executed
branch  1 never executed
    #####:  864:            pn(vm, node->r);
call    0 never executed
    #####:  865:            dbc(OP_DICTGETITEM, 255, 3, NULL);
call    0 never executed
        -:  866:            #if DEBUG_VM
        -:  867:            printf("MOV R255 R3\n");
        -:  868:            #endif
        -:  869:        }
        -:  870:    }break;
        -:  871:    case OP_PUSHDICTELEM:
        -:  872:    break;
        -:  873:    case OP_DICTGETITEM:
        -:  874:    break;
        -:  875:    case OP_DICTSETITEM:
        -:  876:    break;
        -:  877:    /*case NS:
        -:  878:      {
        -:  879:          dbc(OP_NS, 255, 0, NULL);
        -:  880:          pn(node->l);
        -:  881:          dbc(OP_ENDNS, 255, 0, NULL);
        -:  882:      }
        -:  883:      break;*/
        -:  884:    default:
    #####:  885:        printf("nodo_tipo:%i\n", node->tipo);
call    0 never executed
    #####:  886:        return 0;
        -:  887:    }
        -:  888:    // printf("i = %i\n", i);
      360:  889:    return i;
        -:  890:}
