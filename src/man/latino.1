.TH "Latino" "MIT/X11" "Copyright (c) 2015-2019" "Primitivo R."
.SH Sintesis
latino [ \fIopciones\fR ] [ \fIarchivo.lat\fR | \fIcadena\fR ]
.PP
.BR Opciones
.br
-a      : Muestra la ayuda de Latino
.br
-e      : Ejecuta una cadena de codigo
.br
-v      : Muestra la version de Latino
.SH Introducción
.BR "Latino es un nuevo lenguaje de programación para el público en general."
.PP
¿Para qué aprender una nueva sintaxis?
.PP
Hemos visto varios lenguajes de programación, pero ¿Cuándo un lenguaje fácil y en español?
.br
Es cierto que ya existen desarrollados lenguajes en español, pero la idea de Latino, es crear un lenguaje
.br
totalmente fácil tanto para niños como para adultos siendo un lenguaje de programación avanzado.
.PP
¿Que tanto puedo hacer con Latino?
.br
Lo mismo que en cualquier lenguaje de programación, incluye como \fIfunciones\fR
.PP
.PP
.SH Aprendiendo a programar
.PP
.IR Incluir
.PP
En Latino se puede incluir otras librerías de Latino o librerías creadas por nosotros, como
.br
la mayoría de lenguajes de programación.
.PP
La sintaxis es la siguiente:
.RS
.BR incluir('mi_libreria')
.RE
.PP
Como ejemplo, podriamos crear un archivo llamado \fBmi_libreria.lat\fR y lo incluimos con la sintaxis anterior.
.br
Podremos agregar una \fIfuncion\fR y llamarla en otro código incluyendo la librería \fBmi_libreria\fR.
.PP
Posteriormente, podemos crear cualquier otra función o variable en la librería para
.br
así, no necesitar añadir las funciones que vamos a usar en nuestro código principal.
.PP
mi_libreria.lat:
.PP
.RS
\fB
.br
funs = {}
.br
funs.mas10 = funcion(numero)
.RS
poner(numero+10)
.RE
fin
.br
funs.por10 = funcion(numero)
.RS
poner(numero*10)
.RE
fin
.br
funs.menos10 = funcion(numero)
.RS
poner(numero-10)
.RE
fin
.br
funs.entre10 = funcion(numero)
.RS
poner(numero/10)
.RE
fin
.br
ret funs
.RE
.PP
menu.lat:
.PP
.RS
/*
.br
** Funcion Menu: obtiene los argumentos desde que se ejecuta script
.br
** ejemplo: latino script.lat 100
.br
*/
\fB
.br
mis_funs = incluir("mi_libreria")
.br
funcion menu(argc, argv)
.RS
numero_argumentos = argc \fR/* numero argumentos */\fB
.br
numero = argv[1] \fR/* primer argumento */\fB
.br
si numero_argumentos == 1 \fR/* argumento[0] = menu.lat */\fB
.RS
error("Faltan argumentos al ejecutar")
.RE
fin
.br
mis_funs.mas10(numero)
.br
mis_funs.menos10(numero)
.br
mis_funs.por10(numero)
.br
mis_funs.entre10(numero)
.RE
fin
\fR
.RE
.PP
Por último, es \fBimportante\fR recordar que si deseas usar \fBincluir("libreria")\fR sin asignarle
.br
una variable, es necesario usar funciones tipo \fBglobal\fR, en caso contrario, no se incluirán.
.PP
.IR Funciones
.PP
También, podemos crear funciones incluyendo parametros entre parentesis \fB()\fR
.PP
La sintaxis sería la siguiente:
.PP
.RS
/* Funciones locales */
\fB
.br
funcion nombre(argumentos)
.RS
\fR/* Código */\fB
.RE
fin
.PP
/* Funciones globales */
\fB
.br
global funcion nombre(argumentos)
.RS
\fR/* Código */\fB
.RE
fin
\fR
.RE
.RE
.PP
.IR Comentarios
.PP
Si queremos añadir comentarios en el código, podemos hacerlo de varias formas.
.PP
Comentarios simples:
.RS
\fB
.br
// este es un ejemplo de comentario de una línea
.br
# este es otro ejemplo de comentario
\fR
.RE
.PP
Comentarios múltiples:
.RS
\fB
.br
/*
.br
** Este es un
.br
** comentario
.br
** múltiple
.br
*/
\fR
.RE
.PP
.IR Variables
.PP
Podemos declarar una variable simple, para en sí, llamar a funciones de una forma simple.
.PP
Sintaxis de valores declarados:
.RS
\fB
.br
mi_valor="texto"
.br
mi_otro_valor = "prueba"
\fR
.RE
.PP
Como vemos, a diferencia de otras sintaxis, no importa si el valor declarado lleva el símbolo \fB=\fR entre espacios ó no.
.PP
.PP
Por defecto, el alcance de las variables es de manera local (no se incluyen, salen de condiones, etc)
.br
Pero podemos asignarlas de manera global:
.br
.RS
\fB
.br
global variable = valor
\fR
.RE
.PP
.IR Expresiones
.PP
Además, podremos crear expresiones con la impresión de texto, pondremos un ejemplo con \fBescribir()\fR
.PP
Sintaxis:
.br
.RS
.BR poner(1+2)
.RE
.br
Ó, en valores declarados:
.RS
\fB
.br
a=4
.br
suma=a+2
.br
division=a/2
.br
multip=a*2
.br
poner(suma)
\fR
.RE
.PP
Los operadores de expresión son los siguientes:
.br
.RS
.br
.BR +
.br
.BR -
.br
.BR *
.br
.BR /
.br
.BR %
.RE
.PP
.IR "Condiciones (si, osi)"
.PP
Podemos añadir condiciones en Latino (esquema de decisión condicional)
.br
En otras programaciones lo conocerás como if, else, etc.
.br
La sintaxis es la siguiente:
.PP
.RS
/* Condición: establecida por el usuario */
\fB
.br
si condición
.RS
\fR/* Código */\fB
.RE
fin
.PP
/* Condición: variable es igual a...? */
\fB
.br
si variable == "cadena"
.RS
\fR/* Código */\fB
.RE
fin
.PP
/* Condición: variable no es igual a...? */
\fB
.br
si variable != "cadena"
.RS
\fR/* Código */\fB
.RE
fin
.PP
/*
.br
** Condición: variable no es igual a..
.br
** Y
.br
** Condición: variable_2 igual a..
.br
*/
\fB
.br
si variable != "cadena" && variable_2 == 5
.RS
\fR/* Código */\fB
.RE
fin
.PP
/*
.br
** Condición: variable no es igual a..
.br
** O
.br
** Condición: variable no es igual a..
.br
*/
\fB
.br
si variable != "cadena" || variable != 5
.RS
\fR/* Código */\fB
.RE
fin
.PP
/* Podemos ponerlo con ó sin paréntesis, es opcional. */
.br
/* Aquí unos ejemplos: */
\fB
.br
si (condición)
.RS
\fR/* Código */\fB
.RE
fin
.PP
\fB
.br
si (variable == "cadena")
.RS
\fR/* Código */\fB
.RE
fin
.PP
/* Podríamos poner varias condiciones: osi */
\fB
.br
si (condición)
.RS
\fR/* Código */\fB
.RE
osi (otra_condición)
.RS
\fR/* Código */\fB
.RE
fin
\fR
.RE
.PP
.IR "Bucles (mientras, desde, repetir-hasta)"
.PP
Podemos crea un bucle, para así, no salir del script y continue siempre (condición=verdadero)
.br
ó que termine hasta cierta condición.
.PP
Sintaxis:
.RS
/* Creará un bucle con condición */
\fB
.br
mientras (condición)
.RS
\fR/* Código */\fB
.RE
fin
.PP
/* Imprimirá desde 0 a 10 */
\fB
.br
desde(i=0; i<10; i++)
.br
.RS
poner(i)
.RE
fin
.PP
\fB
.br
i = 0
.br
repetir
.br
.RS
poner(i)
.br
i++
.RE
hasta (i >= 10)
\fR
.RE
.PP
.IR "Elegir (switch)"
.PP
Una manera más limpia de condicionar variable a valor igual a, es usando
.br
la sentencia de seleccion \fBelegir\fR:
.PP
.RS
\fB
.br
mi_dinero = 10 \fR/* el valor será 10 */\fB
.br
elegir(mi_dinero)
.br
caso 1: \fR/* si valor==1 */\fB
.RS
poner("Tenemos 1 MXN")  \fR/* hacer... */\fB
.RE
caso 5: \fR/* si valor==5 */\fB
.RS
poner("Tenemos 5 MXN") \fR/* hacer...*/\fB
.RE
caso 10: \fR/* si valor==10 */\fB
.RS
poner("Tenemos 10 MXN") \fR/* hacer... */\fB
.RE
defecto: \fR/* si valor!=1 && valor!=5 && valor!=10 */\fB
.RS
poner("No sé cuanto tenemos.") \fR/* hacer... */\fB
.RE
fin
\fR
.RE
.PP
.IR "Diccionarios - Arrays (unidimensionales, bidimensionales o multidimensionales)"
.PP
También se puede en Latino hacer listas, arrays, diccionarios o como los conozcas:
.PP
.RS
\fB
.br
datos = {
.RS
"gane" : "100 MXN",
.br
"gaste" : "90 MXN",
.br
"tengo" : "10 MXN",
.br
"manzanas":{
.RS
"tengo" : 10,
.br
"colores":[ \fR/*array/dic con lista de cadenas, números o arrays.*/\fB
.RS
"verdes",
.br
"rojas"
.RE
]
.RE
}
.RE
}
.br
poner("Ganamos " .. datos.gane)
.br
poner("Gastamos " .. datos.gaste)
.br
poner("Y nos quedan " .. datos.tengo)
.br
poner("De manzanas, tenemos " .. datos.manzanas.tengo)
.br
desde (i=0; i<dic.longitud(datos.manzanas.colores); i++)
.br
.RS
poner("Color "..i..": "..datos.manzanas.colores[i]) \fR/* Obtiene colores recorriendo lista*/\fB
.RE
.br
fin
\fR
.RE
.SH Copyright
Se concede permiso, de forma gratuita, a cualquier persona que obtenga una copia
.br
de este software y archivos de documentacion asociados (el "Software"), para hacer frente
.br
el Software sin restriccion, incluyendo sin limitacion, los derechos
.br
para usar, copiar, modificar, fusionar, publicar, distribuir, sublicenciar y / o vender
.br
las copias del Software y permitir a las personas a las que el Software es
.br
amueblado para hacerlo, con sujecion a las siguientes condiciones:
.PP
El aviso de copyright anterior y este aviso de permiso se incluiran en
.br
todas las copias o partes sustanciales del Software.
.PP
EL SOFTWARE SE PROPORCIONA "TAL CUAL", SIN GARANTIA DE NINGUN TIPO, EXPRESA O
.br
IMPLICITAS, INCLUYENDO PERO NO LIMITADO A LAS GARANTIAS DE COMERCIALIZACION,
.br
IDONEIDAD PARA UN PROPOSITO PARTICULAR Y NO INFRACCION. EN NINGUN CASO EL
.br
AUTORES O TITULARES DEL COPYRIGHT SERAN RESPONSABLES POR NINGUN RECLAMO, DAÑO U OTRA
.br
RESPONSABILIDAD, YA SEA EN UNA ACCION DE CONTRATO, AGRAVIO O CUALQUIER OTRA FORMA, DERIVADOS DE,
.br
DE O EN RELACION CON EL SOFTWARE O EL USO U OTROS TRATOS EN
.br
EL SOFTWARE.
