        -:    0:Source:/home/latino/src/latino/src/linenoise/linenoise.c
        -:    0:Programs:13
        -:    1:/* linenoise.c -- guerrilla line editing library against the idea that a
        -:    2: * line editing lib needs to be 20,000 lines of C code.
        -:    3: *
        -:    4: * You can find the latest source code at:
        -:    5: *
        -:    6: *   http://github.com/msteveb/linenoise
        -:    7: *   (forked from http://github.com/antirez/linenoise)
        -:    8: *
        -:    9: * Does a number of crazy assumptions that happen to be true in 99.9999% of
        -:   10: * the 2010 UNIX computers around.
        -:   11: *
        -:   12: * ------------------------------------------------------------------------
        -:   13: *
        -:   14: * Copyright (c) 2010, Salvatore Sanfilippo <antirez at gmail dot com>
        -:   15: * Copyright (c) 2010, Pieter Noordhuis <pcnoordhuis at gmail dot com>
        -:   16: * Copyright (c) 2011, Steve Bennett <steveb at workware dot net dot au>
        -:   17: *
        -:   18: * All rights reserved.
        -:   19: *
        -:   20: * Redistribution and use in source and binary forms, with or without
        -:   21: * modification, are permitted provided that the following conditions are
        -:   22: * met:
        -:   23: *
        -:   24: *  *  Redistributions of source code must retain the above copyright
        -:   25: *     notice, this lista of conditions and the following disclaimer.
        -:   26: *
        -:   27: *  *  Redistributions in binary form must reproduce the above copyright
        -:   28: *     notice, this lista of conditions and the following disclaimer in the
        -:   29: *     documentation and/or other materials provided with the distribution.
        -:   30: *
        -:   31: * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
        -:   32: * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
        -:   33: * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
        -:   34: * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
        -:   35: * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
        -:   36: * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
        -:   37: * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
        -:   38: * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
        -:   39: * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   40: * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
        -:   41: * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   42: *
        -:   43: * ------------------------------------------------------------------------
        -:   44: *
        -:   45: * References:
        -:   46: * - http://invisible-island.net/xterm/ctlseqs/ctlseqs.html
        -:   47: * - http://www.3waylabs.com/nw/WWW/products/wizcon/vt220.html
        -:   48: *
        -:   49: * Bloat:
        -:   50: * - Completion?
        -:   51: *
        -:   52: * Unix/termios
        -:   53: * ------------
        -:   54: * List of escape sequences used by this program, we do everything just
        -:   55: * a few sequences. In order to be so cheap we may have some
        -:   56: * flickering effect with some slow terminal, but the lesser sequences
        -:   57: * the more compatible.
        -:   58: *
        -:   59: * EL (Erase Line)
        -:   60: *    Sequence: ESC [ n K
        -:   61: *    Effect: if n is 0 or missing, clear from cursor to end of line
        -:   62: *    Effect: if n is 1, clear from beginning of line to cursor
        -:   63: *    Effect: if n is 2, clear entire line
        -:   64: *
        -:   65: * CUF (CUrsor Forward)
        -:   66: *    Sequence: ESC [ n C
        -:   67: *    Effect: moves cursor forward of n chars
        -:   68: *
        -:   69: * CR (Carriage Return)
        -:   70: *    Sequence: \r
        -:   71: *    Effect: moves cursor to column 1
        -:   72: *
        -:   73: * The following are used to clear the screen: ESC [ H ESC [ 2 J
        -:   74: * This is actually composed of two sequences:
        -:   75: *
        -:   76: * cursorhome
        -:   77: *    Sequence: ESC [ H
        -:   78: *    Effect: moves the cursor to upper left corner
        -:   79: *
        -:   80: * ED2 (Clear entire screen)
        -:   81: *    Sequence: ESC [ 2 J
        -:   82: *    Effect: clear the whole screen
        -:   83: *
        -:   84: * == For highlighting control characters, we also use the following two ==
        -:   85: * SO (enter StandOut)
        -:   86: *    Sequence: ESC [ 7 m
        -:   87: *    Effect: Uses some standout mode such as reverse video
        -:   88: *
        -:   89: * SE (Standout End)
        -:   90: *    Sequence: ESC [ 0 m
        -:   91: *    Effect: Exit standout mode
        -:   92: *
        -:   93: * == Only used if TIOCGWINSZ fails ==
        -:   94: * DSR/CPR (Report cursor position)
        -:   95: *    Sequence: ESC [ 6 n
        -:   96: *    Effect: reports current cursor position as ESC [ NNN ; MMM R
        -:   97: *
        -:   98: * win32/console
        -:   99: * -------------
        -:  100: * If __MINGW32__ is defined, the win32 console API is used.
        -:  101: * This could probably be made to work for the msvc compiler too.
        -:  102: * This support based in part on work by Jon Griffiths.
        -:  103: */
        -:  104:
        -:  105:#ifdef _WIN32 /* Windows platform, either MinGW or Visual Studio (MSVC) */
        -:  106:#include <windows.h>
        -:  107:#include <fcntl.h>
        -:  108:#define USE_WINCONSOLE
        -:  109:#ifdef __MINGW32__
        -:  110:#define HAVE_UNISTD_H
        -:  111:#else
        -:  112:/* Microsoft headers don't like old POSIX names */
        -:  113:#define strdup _strdup
        -:  114:#endif
        -:  115:#else
        -:  116:#include <termios.h>
        -:  117:#include <sys/ioctl.h>
        -:  118:#include <sys/poll.h>
        -:  119:#define USE_TERMIOS
        -:  120:#define HAVE_UNISTD_H
        -:  121:#endif
        -:  122:
        -:  123:#ifdef HAVE_UNISTD_H
        -:  124:#include <unistd.h>
        -:  125:#endif
        -:  126:#include <stdlib.h>
        -:  127:#include <stdarg.h>
        -:  128:#include <stdio.h>
        -:  129:#include <errno.h>
        -:  130:#include <string.h>
        -:  131:#include <sys/types.h>
        -:  132:
        -:  133:#include "linenoise.h"
        -:  134:#include "utf8.h"
        -:  135:
        -:  136:#define LINENOISE_DEFAULT_HISTORY_MAX_LEN 100
        -:  137:#define LINENOISE_MAX_LINE 4096
        -:  138:
        -:  139:#define ctrl(C) ((C) - '@')
        -:  140:
        -:  141:/* Use -ve numbers here to co-exist with normal unicode chars */
        -:  142:enum {
        -:  143:    SPECIAL_NONE,
        -:  144:    SPECIAL_UP = -20,
        -:  145:    SPECIAL_DOWN = -21,
        -:  146:    SPECIAL_LEFT = -22,
        -:  147:    SPECIAL_RIGHT = -23,
        -:  148:    SPECIAL_DELETE = -24,
        -:  149:    SPECIAL_HOME = -25,
        -:  150:    SPECIAL_END = -26,
        -:  151:    SPECIAL_INSERT = -27,
        -:  152:    SPECIAL_PAGE_UP = -28,
        -:  153:    SPECIAL_PAGE_DOWN = -29
        -:  154:};
        -:  155:
        -:  156:static int history_max_len = LINENOISE_DEFAULT_HISTORY_MAX_LEN;
        -:  157:static int history_len = 0;
        -:  158:static char **history = NULL;
        -:  159:
        -:  160:/* Structure to contain the status of the current (being edited) line */
        -:  161:struct current {
        -:  162:    char *buf;  /* Current buffer. Always null terminated */
        -:  163:    int bufmax; /* Size of the buffer, including space for the null termination */
        -:  164:    int len;    /* Number of bytes in 'buf' */
        -:  165:    int chars;  /* Number of chars in 'buf' (utf-8 chars) */
        -:  166:    int pos;    /* Cursor position, measured in chars */
        -:  167:    int cols;   /* Size of the window, in chars */
        -:  168:    const char *prompt;
        -:  169:    char *capture; /* Allocated capture buffer, or NULL for none. Always null terminated */
        -:  170:#if defined(USE_TERMIOS)
        -:  171:    int fd;     /* Terminal fd */
        -:  172:#elif defined(USE_WINCONSOLE)
        -:  173:    HANDLE outh; /* Console output handle */
        -:  174:    HANDLE inh; /* Console input handle */
        -:  175:    int rows;   /* Screen rows */
        -:  176:    int x;      /* Current column during output */
        -:  177:    int y;      /* Current row */
        -:  178:#endif
        -:  179:};
        -:  180:
        -:  181:static int fd_read(struct current *current);
        -:  182:static int getWindowSize(struct current *current);
        -:  183:
function linenoiseHistoryFree called 0 returned 0% blocks executed 0%
    #####:  184:void linenoiseHistoryFree(void) {
    #####:  185:    if (history) {
branch  0 never executed
branch  1 never executed
        -:  186:        int j;
        -:  187:
    #####:  188:        for (j = 0; j < history_len; j++)
branch  0 never executed
branch  1 never executed
    #####:  189:            free(history[j]);
    #####:  190:        free(history);
    #####:  191:        history = NULL;
    #####:  192:        history_len = 0;
        -:  193:    }
    #####:  194:}
        -:  195:
        -:  196:#if defined(USE_TERMIOS)
        -:  197:static void linenoiseAtExit(void);
        -:  198:static struct termios orig_termios; /* in order to restore at exit */
        -:  199:static int rawmode = 0; /* for atexit() function to check if restore is needed*/
        -:  200:static int atexit_registered = 0; /* register atexit just 1 time */
        -:  201:
        -:  202:static const char *unsupported_term[] = {"dumb","cons25",NULL};
        -:  203:
function isUnsupportedTerm called 0 returned 0% blocks executed 0%
    #####:  204:static int isUnsupportedTerm(void) {
    #####:  205:    char *term = getenv("TERM");
call    0 never executed
        -:  206:
    #####:  207:    if (term) {
branch  0 never executed
branch  1 never executed
        -:  208:        int j;
    #####:  209:        for (j = 0; unsupported_term[j]; j++) {
branch  0 never executed
branch  1 never executed
    #####:  210:            if (strcmp(term, unsupported_term[j]) == 0) {
branch  0 never executed
branch  1 never executed
        -:  211:                return 1;
        -:  212:            }
        -:  213:        }
        -:  214:    }
        -:  215:    return 0;
        -:  216:}
        -:  217:
function enableRawMode.isra.3 called 0 returned 0% blocks executed 0%
    #####:  218:static int enableRawMode(struct current *current) {
        -:  219:    struct termios raw;
        -:  220:
    #####:  221:    current->fd = STDIN_FILENO;
    #####:  222:    current->cols = 0;
        -:  223:
    #####:  224:    if (!isatty(current->fd) || isUnsupportedTerm() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  225:        tcgetattr(current->fd, &orig_termios) == -1) {
call    0 never executed
        -:  226:fatal:
    #####:  227:        errno = ENOTTY;
call    0 never executed
        -:  228:        return -1;
        -:  229:    }
        -:  230:
    #####:  231:    if (!atexit_registered) {
branch  0 never executed
branch  1 never executed
    #####:  232:        atexit(linenoiseAtExit);
call    0 never executed
    #####:  233:        atexit_registered = 1;
        -:  234:    }
        -:  235:
    #####:  236:    raw = orig_termios;  /* modify the original mode */
        -:  237:    /* input modes: no break, no CR to NL, no parity check, no strip char,
        -:  238:     * no start/stop output control. */
    #####:  239:    raw.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);
        -:  240:    /* output modes - disable post processing */
    #####:  241:    raw.c_oflag &= ~(OPOST);
        -:  242:    /* control modes - set 8 bit chars */
    #####:  243:    raw.c_cflag |= (CS8);
        -:  244:    /* local modes - choing off, canonical off, no extended functions,
        -:  245:     * no signal chars (^Z,^C) */
    #####:  246:    raw.c_lflag &= ~(ECHO | ICANON | IEXTEN | ISIG);
        -:  247:    /* control chars - set return condition: min number of bytes and timer.
        -:  248:     * We want read to return every single byte, without timeout. */
    #####:  249:    raw.c_cc[VMIN] = 1; raw.c_cc[VTIME] = 0; /* 1 byte, no timer */
        -:  250:
        -:  251:    /* put terminal in raw mode after flushing */
    #####:  252:    if (tcsetattr(current->fd,TCSADRAIN,&raw) < 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  253:        goto fatal;
        -:  254:    }
    #####:  255:    rawmode = 1;
        -:  256:    return 0;
        -:  257:}
        -:  258:
function disableRawMode.isra.2 called 0 returned 0% blocks executed 0%
    #####:  259:static void disableRawMode(struct current *current) {
        -:  260:    /* Don't even check the return value as it's too late. */
    #####:  261:    if (rawmode && tcsetattr(current->fd,TCSADRAIN,&orig_termios) != -1)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  262:        rawmode = 0;
    #####:  263:}
        -:  264:
        -:  265:/* At exit we'll try to fix the terminal to the initial conditions. */
function linenoiseAtExit called 0 returned 0% blocks executed 0%
    #####:  266:static void linenoiseAtExit(void) {
    #####:  267:    if (rawmode) {
branch  0 never executed
branch  1 never executed
    #####:  268:        tcsetattr(STDIN_FILENO, TCSADRAIN, &orig_termios);
call    0 never executed
        -:  269:    }
    #####:  270:    linenoiseHistoryFree();
call    0 never executed
    #####:  271:}
        -:  272:
        -:  273:/* gcc/glibc insists that we care about the return code of write!
        -:  274: * Clarification: This means that a void-cast like "(void) (EXPR)"
        -:  275: * does not work.
        -:  276: */
        -:  277:#define IGNORE_RC(EXPR) if (EXPR) {}
        -:  278:
        -:  279:/* This is fdprintf() on some systems, but use a different
        -:  280: * name to avoid conflicts
        -:  281: */
function fd_printf called 0 returned 0% blocks executed 0%
    #####:  282:static void fd_printf(int fd, const char *format, ...)
        -:  283:{
        -:  284:    va_list args;
        -:  285:    char buf[64];
        -:  286:    int n;
        -:  287:
    #####:  288:    va_start(args, format);
    #####:  289:    n = vsnprintf(buf, sizeof(buf), format, args);
    #####:  290:    va_end(args);
    #####:  291:    IGNORE_RC(write(fd, buf, n));
call    0 never executed
    #####:  292:}
        -:  293:
        -:  294:static void clearScreen(struct current *current)
        -:  295:{
    #####:  296:    fd_printf(current->fd, "\x1b[H\x1b[2J");
call    0 never executed
        -:  297:}
        -:  298:
        -:  299:static void cursorToLeft(struct current *current)
        -:  300:{
    #####:  301:    fd_printf(current->fd, "\r");
call    0 never executed
        -:  302:}
        -:  303:
        -:  304:static int outputChars(struct current *current, const char *buf, int len)
        -:  305:{
    #####:  306:    return write(current->fd, buf, len);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  307:}
        -:  308:
        -:  309:static void outputControlChar(struct current *current, char ch)
        -:  310:{
    #####:  311:    fd_printf(current->fd, "\x1b[7m^%c\x1b[0m", ch);
call    0 never executed
        -:  312:}
        -:  313:
        -:  314:static void eraseEol(struct current *current)
        -:  315:{
    #####:  316:    fd_printf(current->fd, "\x1b[0K");
call    0 never executed
        -:  317:}
        -:  318:
        -:  319:static void setCursorPos(struct current *current, int x)
        -:  320:{
    #####:  321:    fd_printf(current->fd, "\r\x1b[%dC", x);
call    0 never executed
        -:  322:}
        -:  323:
        -:  324:/**
        -:  325: * Reads a char from 'fd', waiting at most 'timeout' milliseconds.
        -:  326: *
        -:  327: * A timeout of -1 means to wait forever.
        -:  328: *
        -:  329: * Returns -1 if no char is received within the time or an error occurs.
        -:  330: */
function fd_read_char called 0 returned 0% blocks executed 0%
    #####:  331:static int fd_read_char(int fd, int timeout)
        -:  332:{
        -:  333:    struct pollfd p;
        -:  334:    unsigned char c;
        -:  335:
    #####:  336:    p.fd = fd;
    #####:  337:    p.events = POLLIN;
        -:  338:
    #####:  339:    if (poll(&p, 1, timeout) == 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  340:        /* timeout */
        -:  341:        return -1;
        -:  342:    }
    #####:  343:    if (read(fd, &c, 1) != 1) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  344:        return -1;
        -:  345:    }
    #####:  346:    return c;
        -:  347:}
        -:  348:
        -:  349:/**
        -:  350: * Reads a complete utf-8 character
        -:  351: * and returns the unicode value, or -1 on error.
        -:  352: */
        -:  353:static int fd_read(struct current *current)
        -:  354:{
        -:  355:#ifdef USE_UTF8
        -:  356:    char buf[4];
        -:  357:    int n;
        -:  358:    int i;
        -:  359:    int c;
        -:  360:
        -:  361:    if (read(current->fd, &buf[0], 1) != 1) {
        -:  362:        return -1;
        -:  363:    }
        -:  364:    n = utf8_charlen(buf[0]);
        -:  365:    if (n < 1 || n > 3) {
        -:  366:        return -1;
        -:  367:    }
        -:  368:    for (i = 1; i < n; i++) {
        -:  369:        if (read(current->fd, &buf[i], 1) != 1) {
        -:  370:            return -1;
        -:  371:        }
        -:  372:    }
        -:  373:    buf[n] = 0;
        -:  374:    /* decode and return the character */
        -:  375:    utf8_tounicode(buf, &c);
        -:  376:    return c;
        -:  377:#else
    #####:  378:    return fd_read_char(current->fd, -1);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  379:#endif
        -:  380:}
        -:  381:
function countColorControlChars called 0 returned 0% blocks executed 0%
    #####:  382:static int countColorControlChars(const char* prompt)
        -:  383:{
        -:  384:    /* ANSI color control sequences have the form:
        -:  385:     * "\x1b" "[" [0-9;]* "m"
        -:  386:     * We parse them with a simple state machine.
        -:  387:     */
        -:  388:
        -:  389:    enum {
        -:  390:        search_esc,
        -:  391:        expect_bracket,
        -:  392:        expect_trail
        -:  393:    } state = search_esc;
        -:  394:    int len = 0, found = 0;
        -:  395:    char ch;
        -:  396:
        -:  397:    /* XXX: Strictly we should be checking utf8 chars rather than
        -:  398:     *      bytes in case of the extremely unlikely scenario where
        -:  399:     *      an ANSI sequence is part of a utf8 sequence.
        -:  400:     */
    #####:  401:    while ((ch = *prompt++) != 0) {
branch  0 never executed
branch  1 never executed
    #####:  402:        switch (state) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  403:        case search_esc:
    #####:  404:            if (ch == '\x1b') {
branch  0 never executed
branch  1 never executed
        -:  405:                state = expect_bracket;
        -:  406:            }
        -:  407:            break;
        -:  408:        case expect_bracket:
    #####:  409:            if (ch == '[') {
branch  0 never executed
branch  1 never executed
        -:  410:                state = expect_trail;
        -:  411:                /* 3 for "\e[ ... m" */
        -:  412:                len = 3;
        -:  413:                break;
        -:  414:            }
        -:  415:            state = search_esc;
    #####:  416:            break;
        -:  417:        case expect_trail:
    #####:  418:            if ((ch == ';') || ((ch >= '0' && ch <= '9'))) {
branch  0 never executed
branch  1 never executed
        -:  419:                /* 0-9, or semicolon */
    #####:  420:                len++;
    #####:  421:                break;
        -:  422:            }
    #####:  423:            if (ch == 'm') {
branch  0 never executed
branch  1 never executed
    #####:  424:                found += len;
        -:  425:            }
        -:  426:            state = search_esc;
        -:  427:            break;
        -:  428:        }
        -:  429:    }
        -:  430:
    #####:  431:    return found;
        -:  432:}
        -:  433:
        -:  434:/**
        -:  435: * Stores the current cursor column in '*cols'.
        -:  436: * Returns 1 if OK, or 0 if failed to determine cursor pos.
        -:  437: */
function queryCursor called 0 returned 0% blocks executed 0%
    #####:  438:static int queryCursor(int fd, int* cols)
        -:  439:{
        -:  440:    /* control sequence - report cursor location */
    #####:  441:    fd_printf(fd, "\x1b[6n");
call    0 never executed
        -:  442:
        -:  443:    /* Parse the response: ESC [ rows ; cols R */
    #####:  444:    if (fd_read_char(fd, 100) == 0x1b &&
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  445:        fd_read_char(fd, 100) == '[') {
call    0 never executed
        -:  446:
        -:  447:        int n = 0;
        -:  448:        while (1) {
    #####:  449:            int ch = fd_read_char(fd, 100);
call    0 never executed
    #####:  450:            if (ch == ';') {
branch  0 never executed
branch  1 never executed
        -:  451:                /* Ignore rows */
        -:  452:                n = 0;
        -:  453:            }
    #####:  454:            else if (ch == 'R') {
branch  0 never executed
branch  1 never executed
        -:  455:                /* Got cols */
    #####:  456:                if (n != 0 && n < 1000) {
branch  0 never executed
branch  1 never executed
    #####:  457:                    *cols = n;
        -:  458:                }
        -:  459:                break;
        -:  460:            }
    #####:  461:            else if (ch >= 0 && ch <= '9') {
branch  0 never executed
branch  1 never executed
    #####:  462:                n = n * 10 + ch - '0';
        -:  463:            }
        -:  464:            else {
        -:  465:                break;
        -:  466:            }
        -:  467:        }
        -:  468:        return 1;
        -:  469:    }
        -:  470:
        -:  471:    return 0;
        -:  472:}
        -:  473:
        -:  474:/**
        -:  475: * Updates current->cols with the current window size (width)
        -:  476: */
function getWindowSize called 0 returned 0% blocks executed 0%
    #####:  477:static int getWindowSize(struct current *current)
        -:  478:{
        -:  479:    struct winsize ws;
        -:  480:
    #####:  481:    if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &ws) == 0 && ws.ws_col != 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  482:        current->cols = ws.ws_col;
    #####:  483:        return 0;
        -:  484:    }
        -:  485:
        -:  486:    /* Failed to query the window size. Perhaps we are on a serial terminal.
        -:  487:     * Try to query the width by sending the cursor as far to the right
        -:  488:     * and reading back the cursor position.
        -:  489:     * Note that this is only done once per call to linenoise rather than
        -:  490:     * every time the line is refreshed for efficiency reasons.
        -:  491:     *
        -:  492:     * In more detail, we:
        -:  493:     * (a) request current cursor position,
        -:  494:     * (b) move cursor far right,
        -:  495:     * (c) request cursor position again,
        -:  496:     * (d) at last move back to the old position.
        -:  497:     * This gives us the width without messing with the externally
        -:  498:     * visible cursor position.
        -:  499:     */
        -:  500:
    #####:  501:    if (current->cols == 0) {
branch  0 never executed
branch  1 never executed
        -:  502:        int here;
        -:  503:
    #####:  504:        current->cols = 80;
        -:  505:
        -:  506:        /* (a) */
    #####:  507:        if (queryCursor (current->fd, &here)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  508:            /* (b) */
    #####:  509:            fd_printf(current->fd, "\x1b[999C");
call    0 never executed
        -:  510:
        -:  511:            /* (c). Note: If (a) succeeded, then (c) should as well.
        -:  512:             * For paranoia we still check and have a fallback action
        -:  513:             * for (d) in case of failure..
        -:  514:             */
    #####:  515:            if (!queryCursor (current->fd, &current->cols)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  516:                /* (d') Unable to get accurate position data, reset
        -:  517:                 * the cursor to the far left. While this may not
        -:  518:                 * restore the exact original position it should not
        -:  519:                 * be too bad.
        -:  520:                 */
    #####:  521:                fd_printf(current->fd, "\r");
call    0 never executed
        -:  522:            } else {
        -:  523:                /* (d) Reset the cursor back to the original location. */
    #####:  524:                if (current->cols > here) {
branch  0 never executed
branch  1 never executed
    #####:  525:                    fd_printf(current->fd, "\x1b[%dD", current->cols - here);
call    0 never executed
        -:  526:                }
        -:  527:            }
        -:  528:        } /* 1st query failed, doing nothing => default 80 */
        -:  529:    }
        -:  530:
        -:  531:    return 0;
        -:  532:}
        -:  533:
        -:  534:/**
        -:  535: * If escape (27) was received, reads subsequent
        -:  536: * chars to determine if this is a known special key.
        -:  537: *
        -:  538: * Returns SPECIAL_NONE if unrecognised, or -1 if EOF.
        -:  539: *
        -:  540: * If no additional char is received within a short time,
        -:  541: * 27 is returned.
        -:  542: */
function check_special called 0 returned 0% blocks executed 0%
    #####:  543:static int check_special(int fd)
        -:  544:{
    #####:  545:    int c = fd_read_char(fd, 50);
call    0 never executed
        -:  546:    int c2;
        -:  547:
    #####:  548:    if (c < 0) {
branch  0 never executed
branch  1 never executed
        -:  549:        return 27;
        -:  550:    }
        -:  551:
    #####:  552:    c2 = fd_read_char(fd, 50);
call    0 never executed
    #####:  553:    if (c2 < 0) {
branch  0 never executed
branch  1 never executed
        -:  554:        return c2;
        -:  555:    }
    #####:  556:    if (c == '[' || c == 'O') {
branch  0 never executed
branch  1 never executed
        -:  557:        /* Potential arrow key */
    #####:  558:        switch (c2) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -:  559:            case 'A':
        -:  560:                return SPECIAL_UP;
        -:  561:            case 'B':
    #####:  562:                return SPECIAL_DOWN;
        -:  563:            case 'C':
    #####:  564:                return SPECIAL_RIGHT;
        -:  565:            case 'D':
    #####:  566:                return SPECIAL_LEFT;
        -:  567:            case 'F':
    #####:  568:                return SPECIAL_END;
        -:  569:            case 'H':
    #####:  570:                return SPECIAL_HOME;
        -:  571:        }
        -:  572:    }
    #####:  573:    if (c == '[' && c2 >= '1' && c2 <= '8') {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  574:        /* extended escape */
    #####:  575:        c = fd_read_char(fd, 50);
call    0 never executed
    #####:  576:        if (c == '~') {
branch  0 never executed
branch  1 never executed
    #####:  577:            switch (c2) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -:  578:                case '2':
        -:  579:                    return SPECIAL_INSERT;
        -:  580:                case '3':
    #####:  581:                    return SPECIAL_DELETE;
        -:  582:                case '5':
    #####:  583:                    return SPECIAL_PAGE_UP;
        -:  584:                case '6':
    #####:  585:                    return SPECIAL_PAGE_DOWN;
        -:  586:                case '7':
    #####:  587:                    return SPECIAL_HOME;
        -:  588:                case '8':
    #####:  589:                    return SPECIAL_END;
        -:  590:            }
        -:  591:        }
    #####:  592:        while (c != -1 && c != '~') {
branch  0 never executed
branch  1 never executed
        -:  593:            /* .e.g \e[12~ or '\e[11;2~   discard the complete sequence */
    #####:  594:            c = fd_read_char(fd, 50);
call    0 never executed
        -:  595:        }
        -:  596:    }
        -:  597:
        -:  598:    return SPECIAL_NONE;
        -:  599:}
        -:  600:#elif defined(USE_WINCONSOLE)
        -:  601:
        -:  602:static DWORD orig_consolemode = 0;
        -:  603:
        -:  604:static int enableRawMode(struct current *current) {
        -:  605:    DWORD n;
        -:  606:    INPUT_RECORD irec;
        -:  607:
        -:  608:    current->outh = GetStdHandle(STD_OUTPUT_HANDLE);
        -:  609:    current->inh = GetStdHandle(STD_INPUT_HANDLE);
        -:  610:
        -:  611:    if (!PeekConsoleInput(current->inh, &irec, 1, &n)) {
        -:  612:        return -1;
        -:  613:    }
        -:  614:    if (getWindowSize(current) != 0) {
        -:  615:        return -1;
        -:  616:    }
        -:  617:    if (GetConsoleMode(current->inh, &orig_consolemode)) {
        -:  618:        SetConsoleMode(current->inh, ENABLE_PROCESSED_INPUT);
        -:  619:    }
        -:  620:    return 0;
        -:  621:}
        -:  622:
        -:  623:static void disableRawMode(struct current *current)
        -:  624:{
        -:  625:    SetConsoleMode(current->inh, orig_consolemode);
        -:  626:}
        -:  627:
        -:  628:static void clearScreen(struct current *current)
        -:  629:{
        -:  630:    COORD topleft = { 0, 0 };
        -:  631:    DWORD n;
        -:  632:
        -:  633:    FillConsoleOutputCharacter(current->outh, ' ',
        -:  634:        current->cols * current->rows, topleft, &n);
        -:  635:    FillConsoleOutputAttribute(current->outh,
        -:  636:        FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_GREEN,
        -:  637:        current->cols * current->rows, topleft, &n);
        -:  638:    SetConsoleCursorPosition(current->outh, topleft);
        -:  639:}
        -:  640:
        -:  641:static void cursorToLeft(struct current *current)
        -:  642:{
        -:  643:    COORD pos;
        -:  644:    DWORD n;
        -:  645:
        -:  646:    pos.X = 0;
        -:  647:    pos.Y = (SHORT)current->y;
        -:  648:
        -:  649:    FillConsoleOutputAttribute(current->outh,
        -:  650:        FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_GREEN, current->cols, pos, &n);
        -:  651:    current->x = 0;
        -:  652:}
        -:  653:
        -:  654:static int outputChars(struct current *current, const char *buf, int len)
        -:  655:{
        -:  656:    COORD pos;
        -:  657:    DWORD n;
        -:  658:
        -:  659:    pos.X = (SHORT)current->x;
        -:  660:    pos.Y = (SHORT)current->y;
        -:  661:
        -:  662:    WriteConsoleOutputCharacter(current->outh, buf, len, pos, &n);
        -:  663:    current->x += len;
        -:  664:    return 0;
        -:  665:}
        -:  666:
        -:  667:static void outputControlChar(struct current *current, char ch)
        -:  668:{
        -:  669:    COORD pos;
        -:  670:    DWORD n;
        -:  671:
        -:  672:    pos.X = (SHORT) current->x;
        -:  673:    pos.Y = (SHORT) current->y;
        -:  674:
        -:  675:    FillConsoleOutputAttribute(current->outh, BACKGROUND_INTENSITY, 2, pos, &n);
        -:  676:    outputChars(current, "^", 1);
        -:  677:    outputChars(current, &ch, 1);
        -:  678:}
        -:  679:
        -:  680:static void eraseEol(struct current *current)
        -:  681:{
        -:  682:    COORD pos;
        -:  683:    DWORD n;
        -:  684:
        -:  685:    pos.X = (SHORT) current->x;
        -:  686:    pos.Y = (SHORT) current->y;
        -:  687:
        -:  688:    FillConsoleOutputCharacter(current->outh, ' ', current->cols - current->x, pos, &n);
        -:  689:}
        -:  690:
        -:  691:static void setCursorPos(struct current *current, int x)
        -:  692:{
        -:  693:    COORD pos;
        -:  694:
        -:  695:    pos.X = (SHORT)x;
        -:  696:    pos.Y = (SHORT) current->y;
        -:  697:
        -:  698:    SetConsoleCursorPosition(current->outh, pos);
        -:  699:    current->x = x;
        -:  700:}
        -:  701:
        -:  702:static int fd_read(struct current *current)
        -:  703:{
        -:  704:    while (1) {
        -:  705:        INPUT_RECORD irec;
        -:  706:        DWORD n;
        -:  707:        if (WaitForSingleObject(current->inh, INFINITE) != WAIT_OBJECT_0) {
        -:  708:            break;
        -:  709:        }
        -:  710:        if (!ReadConsoleInput (current->inh, &irec, 1, &n)) {
        -:  711:            break;
        -:  712:        }
        -:  713:        if (irec.EventType == KEY_EVENT && irec.Event.KeyEvent.bKeyDown) {
        -:  714:            KEY_EVENT_RECORD *k = &irec.Event.KeyEvent;
        -:  715:            if (k->dwControlKeyState & ENHANCED_KEY) {
        -:  716:                switch (k->wVirtualKeyCode) {
        -:  717:                 case VK_LEFT:
        -:  718:                    return SPECIAL_LEFT;
        -:  719:                 case VK_RIGHT:
        -:  720:                    return SPECIAL_RIGHT;
        -:  721:                 case VK_UP:
        -:  722:                    return SPECIAL_UP;
        -:  723:                 case VK_DOWN:
        -:  724:                    return SPECIAL_DOWN;
        -:  725:                 case VK_INSERT:
        -:  726:                    return SPECIAL_INSERT;
        -:  727:                 case VK_DELETE:
        -:  728:                    return SPECIAL_DELETE;
        -:  729:                 case VK_HOME:
        -:  730:                    return SPECIAL_HOME;
        -:  731:                 case VK_END:
        -:  732:                    return SPECIAL_END;
        -:  733:                 case VK_PRIOR:
        -:  734:                    return SPECIAL_PAGE_UP;
        -:  735:                 case VK_NEXT:
        -:  736:                    return SPECIAL_PAGE_DOWN;
        -:  737:                }
        -:  738:            }
        -:  739:            /* Note that control characters are already translated in AsciiChar */
        -:  740:            else if (k->wVirtualKeyCode == VK_CONTROL)
        -:  741:	        continue;
        -:  742:            else {
        -:  743:#ifdef USE_UTF8
        -:  744:                return k->uChar.UnicodeChar;
        -:  745:#else
        -:  746:                return k->uChar.AsciiChar;
        -:  747:#endif
        -:  748:            }
        -:  749:        }
        -:  750:    }
        -:  751:    return -1;
        -:  752:}
        -:  753:
        -:  754:static int countColorControlChars(const char* prompt)
        -:  755:{
        -:  756:    /* For windows we assume that there are no embedded ansi color
        -:  757:     * control sequences.
        -:  758:     */
        -:  759:    return 0;
        -:  760:}
        -:  761:
        -:  762:static int getWindowSize(struct current *current)
        -:  763:{
        -:  764:    CONSOLE_SCREEN_BUFFER_INFO info;
        -:  765:    if (!GetConsoleScreenBufferInfo(current->outh, &info)) {
        -:  766:        return -1;
        -:  767:    }
        -:  768:    current->cols = info.dwSize.X;
        -:  769:    current->rows = info.dwSize.Y;
        -:  770:    if (current->cols <= 0 || current->rows <= 0) {
        -:  771:        current->cols = 80;
        -:  772:        return -1;
        -:  773:    }
        -:  774:    current->y = info.dwCursorPosition.Y;
        -:  775:    current->x = info.dwCursorPosition.X;
        -:  776:    return 0;
        -:  777:}
        -:  778:#endif
        -:  779:
        -:  780:static int utf8_getchars(char *buf, int c)
        -:  781:{
        -:  782:#ifdef USE_UTF8
        -:  783:    return utf8_fromunicode(buf, c);
        -:  784:#else
    #####:  785:    *buf = c;
        -:  786:    return 1;
        -:  787:#endif
        -:  788:}
        -:  789:
        -:  790:/**
        -:  791: * Returns the unicode character at the given offset,
        -:  792: * or -1 if none.
        -:  793: */
        -:  794:static int get_char(struct current *current, int pos)
        -:  795:{
    #####:  796:    if (pos >= 0 && pos < current->chars) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
        -:  797:        int c;
        -:  798:        int i = utf8_index(current->buf, pos);
    #####:  799:        (void)utf8_tounicode(current->buf + i, &c);
        -:  800:        return c;
        -:  801:    }
        -:  802:    return -1;
        -:  803:}
        -:  804:
function refreshLine called 0 returned 0% blocks executed 0%
    #####:  805:static void refreshLine(const char *prompt, struct current *current)
        -:  806:{
        -:  807:    int plen;
        -:  808:    int pchars;
        -:  809:    int backup = 0;
        -:  810:    int i;
    #####:  811:    const char *buf = current->buf;
    #####:  812:    int chars = current->chars;
    #####:  813:    int pos = current->pos;
        -:  814:    int b;
        -:  815:    int ch;
        -:  816:    int n;
        -:  817:
        -:  818:    /* Should intercept SIGWINCH. For now, just get the size every time */
    #####:  819:    getWindowSize(current);
call    0 never executed
        -:  820:
    #####:  821:    plen = strlen(prompt);
        -:  822:    pchars = utf8_strlen(prompt, plen);
        -:  823:
        -:  824:    /* Scan the prompt for embedded ansi color control sequences and
        -:  825:     * discount them as characters/columns.
        -:  826:     */
    #####:  827:    pchars -= countColorControlChars(prompt);
call    0 never executed
        -:  828:
        -:  829:    /* Account for a line which is too long to fit in the window.
        -:  830:     * Note that control chars require an extra column
        -:  831:     */
        -:  832:
        -:  833:    /* How many cols are required to the left of 'pos'?
        -:  834:     * The prompt, plus one extra for each control char
        -:  835:     */
    #####:  836:    n = pchars + utf8_strlen(buf, current->len);
branch  0 never executed
branch  1 never executed
        -:  837:    b = 0;
    #####:  838:    for (i = 0; i < pos; i++) {
branch  0 never executed
branch  1 never executed
    #####:  839:        b += utf8_tounicode(buf + b, &ch);
    #####:  840:        if (ch < ' ') {
branch  0 never executed
branch  1 never executed
    #####:  841:            n++;
        -:  842:        }
        -:  843:    }
        -:  844:
        -:  845:    /* If too many are needed, strip chars off the front of 'buf'
        -:  846:     * until it fits. Note that if the current char is a control character,
        -:  847:     * we need one extra col.
        -:  848:     */
    #####:  849:    if (current->pos < current->chars && get_char(current, current->pos) < ' ') {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  850:        n++;
        -:  851:    }
        -:  852:
    #####:  853:    while (n >= current->cols && pos > 0) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  854:        b = utf8_tounicode(buf, &ch);
    #####:  855:        if (ch < ' ') {
branch  0 never executed
branch  1 never executed
    #####:  856:            n--;
        -:  857:        }
    #####:  858:        n--;
    #####:  859:        buf += b;
    #####:  860:        pos--;
    #####:  861:        chars--;
        -:  862:    }
        -:  863:
        -:  864:    /* Cursor to left edge, then the prompt */
        -:  865:    cursorToLeft(current);
        -:  866:    outputChars(current, prompt, plen);
        -:  867:
        -:  868:    /* Now the current buffer content */
        -:  869:
        -:  870:    /* Need special handling for control characters.
        -:  871:     * If we hit 'cols', stop.
        -:  872:     */
        -:  873:    b = 0; /* unwritted bytes */
        -:  874:    n = 0; /* How many control chars were written */
    #####:  875:    for (i = 0; i < chars; i++) {
branch  0 never executed
branch  1 never executed
        -:  876:        int ch;
    #####:  877:        int w = utf8_tounicode(buf + b, &ch);
    #####:  878:        if (ch < ' ') {
branch  0 never executed
branch  1 never executed
    #####:  879:            n++;
        -:  880:        }
    #####:  881:        if (pchars + i + n >= current->cols) {
branch  0 never executed
branch  1 never executed
        -:  882:            break;
        -:  883:        }
    #####:  884:        if (ch < ' ') {
branch  0 never executed
branch  1 never executed
        -:  885:            /* A control character, so write the buffer so far */
        -:  886:            outputChars(current, buf, b);
    #####:  887:            buf += b + w;
        -:  888:            b = 0;
    #####:  889:            outputControlChar(current, ch + '@');
    #####:  890:            if (i < pos) {
branch  0 never executed
branch  1 never executed
    #####:  891:                backup++;
        -:  892:            }
        -:  893:        }
        -:  894:        else {
    #####:  895:            b += w;
        -:  896:        }
        -:  897:    }
        -:  898:    outputChars(current, buf, b);
        -:  899:
        -:  900:    /* Erase to right, move cursor to original position */
        -:  901:    eraseEol(current);
    #####:  902:    setCursorPos(current, pos + pchars + backup);
    #####:  903:}
        -:  904:
function set_current called 0 returned 0% blocks executed 0%
    #####:  905:static void set_current(struct current *current, const char *str)
        -:  906:{
    #####:  907:    strncpy(current->buf, str, current->bufmax);
    #####:  908:    current->buf[current->bufmax - 1] = 0;
    #####:  909:    current->len = strlen(current->buf);
    #####:  910:    current->pos = current->chars = utf8_strlen(current->buf, current->len);
branch  0 never executed
branch  1 never executed
    #####:  911:}
        -:  912:
        -:  913:static int has_room(struct current *current, int bytes)
        -:  914:{
    #####:  915:    return current->len + bytes < current->bufmax - 1;
        -:  916:}
        -:  917:
        -:  918:/**
        -:  919: * Removes the char at 'pos'.
        -:  920: *
        -:  921: * Returns 1 if the line needs to be refreshed, 2 if not
        -:  922: * and 0 if nothing was removed
        -:  923: */
function remove_char called 0 returned 0% blocks executed 0%
    #####:  924:static int remove_char(struct current *current, int pos)
        -:  925:{
    #####:  926:    if (pos >= 0 && pos < current->chars) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  927:        int p1, p2;
        -:  928:        int ret = 1;
        -:  929:        p1 = utf8_index(current->buf, pos);
    #####:  930:        p2 = p1 + utf8_index(current->buf + p1, 1);
        -:  931:
        -:  932:#ifdef USE_TERMIOS
        -:  933:        /* optimise remove char in the case of removing the last char */
    #####:  934:        if (current->pos == pos + 1 && current->pos == current->chars) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  935:            if (current->buf[pos] >= ' ' && utf8_strlen(current->prompt, -1) + utf8_strlen(current->buf, current->len) < current->cols - 1) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  936:                ret = 2;
    #####:  937:                fd_printf(current->fd, "\b \b");
call    0 never executed
        -:  938:            }
        -:  939:        }
        -:  940:#endif
        -:  941:
        -:  942:        /* Move the null char too */
    #####:  943:        memmove(current->buf + p1, current->buf + p2, current->len - p2 + 1);
    #####:  944:        current->len -= (p2 - p1);
    #####:  945:        current->chars--;
        -:  946:
    #####:  947:        if (current->pos > pos) {
branch  0 never executed
branch  1 never executed
    #####:  948:            current->pos--;
        -:  949:        }
    #####:  950:        return ret;
        -:  951:    }
        -:  952:    return 0;
        -:  953:}
        -:  954:
        -:  955:/**
        -:  956: * Insert 'ch' at position 'pos'
        -:  957: *
        -:  958: * Returns 1 if the line needs to be refreshed, 2 if not
        -:  959: * and 0 if nothing was inserted (no room)
        -:  960: */
function insert_char called 0 returned 0% blocks executed 0%
    #####:  961:static int insert_char(struct current *current, int pos, int ch)
        -:  962:{
        -:  963:    char buf[3];
        -:  964:    int n = utf8_getchars(buf, ch);
        -:  965:
    #####:  966:    if (has_room(current, n) && pos >= 0 && pos <= current->chars) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  967:        int p1, p2;
        -:  968:        int ret = 1;
        -:  969:        p1 = utf8_index(current->buf, pos);
    #####:  970:        p2 = p1 + n;
        -:  971:
        -:  972:#ifdef USE_TERMIOS
        -:  973:        /* optimise the case where adding a single char to the end and no scrolling is needed */
    #####:  974:        if (current->pos == pos && current->chars == pos) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  975:            if (ch >= ' ' && utf8_strlen(current->prompt, -1) + utf8_strlen(current->buf, current->len) < current->cols - 1) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  976:                IGNORE_RC(write(current->fd, buf, n));
call    0 never executed
        -:  977:                ret = 2;
        -:  978:            }
        -:  979:        }
        -:  980:#endif
        -:  981:
    #####:  982:        memmove(current->buf + p2, current->buf + p1, current->len - p1);
    #####:  983:        memcpy(current->buf + p1, buf, n);
    #####:  984:        current->len += n;
        -:  985:
    #####:  986:        current->chars++;
    #####:  987:        if (current->pos >= pos) {
branch  0 never executed
branch  1 never executed
    #####:  988:            current->pos++;
        -:  989:        }
    #####:  990:        return ret;
        -:  991:    }
        -:  992:    return 0;
        -:  993:}
        -:  994:
        -:  995:/**
        -:  996: * Captures up to 'n' characters starting at 'pos' for the cut buffer.
        -:  997: *
        -:  998: * This replaces any existing characters in the cut buffer.
        -:  999: */
function capture_chars called 0 returned 0% blocks executed 0%
    #####: 1000:static void capture_chars(struct current *current, int pos, int n)
        -: 1001:{
    #####: 1002:    if (pos >= 0 && (pos + n - 1) < current->chars) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1003:        int p1 = utf8_index(current->buf, pos);
        -: 1004:        int nbytes = utf8_index(current->buf + p1, n);
        -: 1005:
    #####: 1006:        if (nbytes) {
branch  0 never executed
branch  1 never executed
    #####: 1007:            free(current->capture);
        -: 1008:            /* Include space for the null terminator */
    #####: 1009:            current->capture = (char *)malloc(nbytes + 1);
    #####: 1010:            memcpy(current->capture, current->buf + p1, nbytes);
    #####: 1011:            current->capture[nbytes] = '\0';
        -: 1012:        }
        -: 1013:    }
    #####: 1014:}
        -: 1015:
        -: 1016:/**
        -: 1017: * Removes up to 'n' characters at cursor position 'pos'.
        -: 1018: *
        -: 1019: * Returns 0 if no chars were removed or non-zero otherwise.
        -: 1020: */
function remove_chars called 0 returned 0% blocks executed 0%
    #####: 1021:static int remove_chars(struct current *current, int pos, int n)
        -: 1022:{
        -: 1023:    int removed = 0;
        -: 1024:
        -: 1025:    /* First save any chars which will be removed */
    #####: 1026:    capture_chars(current, pos, n);
call    0 never executed
        -: 1027:
    #####: 1028:    while (n-- && remove_char(current, pos)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1029:        removed++;
        -: 1030:    }
    #####: 1031:    return removed;
        -: 1032:}
        -: 1033:/**
        -: 1034: * Inserts the characters (string) 'chars' at the cursor position 'pos'.
        -: 1035: *
        -: 1036: * Returns 0 if no chars were inserted or non-zero otherwise.
        -: 1037: */
function insert_chars called 0 returned 0% blocks executed 0%
    #####: 1038:static int insert_chars(struct current *current, int pos, const char *chars)
        -: 1039:{
        -: 1040:    int inserted = 0;
        -: 1041:
    #####: 1042:    while (*chars) {
branch  0 never executed
branch  1 never executed
        -: 1043:        int ch;
    #####: 1044:        int n = utf8_tounicode(chars, &ch);
    #####: 1045:        if (insert_char(current, pos, ch) == 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1046:            break;
        -: 1047:        }
    #####: 1048:        inserted++;
    #####: 1049:        pos++;
    #####: 1050:        chars += n;
        -: 1051:    }
    #####: 1052:    return inserted;
        -: 1053:}
        -: 1054:
        -: 1055:#ifndef NO_COMPLETION
        -: 1056:static linenoiseCompletionCallback *completionCallback = NULL;
        -: 1057:
function beep called 0 returned 0% blocks executed 0%
    #####: 1058:static void beep() {
        -: 1059:#ifdef USE_TERMIOS
    #####: 1060:    fprintf(stderr, "\x7");
call    0 never executed
    #####: 1061:    fflush(stderr);
call    0 never executed
        -: 1062:#endif
    #####: 1063:}
        -: 1064:
function freeCompletions called 0 returned 0% blocks executed 0%
    #####: 1065:static void freeCompletions(linenoiseCompletions *lc) {
        -: 1066:    size_t i;
    #####: 1067:    for (i = 0; i < lc->len; i++)
branch  0 never executed
branch  1 never executed
    #####: 1068:        free(lc->cvec[i]);
    #####: 1069:    free(lc->cvec);
    #####: 1070:}
        -: 1071:
function completeLine called 0 returned 0% blocks executed 0%
    #####: 1072:static int completeLine(struct current *current) {
    #####: 1073:    linenoiseCompletions lc = { 0, NULL };
        -: 1074:    int c = 0;
        -: 1075:
    #####: 1076:    completionCallback(current->buf,&lc);
call    0 never executed
    #####: 1077:    if (lc.len == 0) {
branch  0 never executed
branch  1 never executed
    #####: 1078:        beep();
call    0 never executed
        -: 1079:    } else {
        -: 1080:        size_t stop = 0, i = 0;
        -: 1081:
    #####: 1082:        while(!stop) {
branch  0 never executed
branch  1 never executed
        -: 1083:            /* Show completion or original buffer */
    #####: 1084:            if (i < lc.len) {
branch  0 never executed
branch  1 never executed
    #####: 1085:                struct current tmp = *current;
    #####: 1086:                tmp.buf = lc.cvec[i];
    #####: 1087:                tmp.pos = tmp.len = strlen(tmp.buf);
    #####: 1088:                tmp.chars = utf8_strlen(tmp.buf, tmp.len);
branch  0 never executed
branch  1 never executed
    #####: 1089:                refreshLine(current->prompt, &tmp);
call    0 never executed
        -: 1090:            } else {
    #####: 1091:                refreshLine(current->prompt, current);
call    0 never executed
        -: 1092:            }
        -: 1093:
        -: 1094:            c = fd_read(current);
    #####: 1095:            if (c == -1) {
branch  0 never executed
branch  1 never executed
        -: 1096:                break;
        -: 1097:            }
        -: 1098:
    #####: 1099:            switch(c) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
        -: 1100:                case '\t': /* tab */
    #####: 1101:                    i = (i+1) % (lc.len+1);
    #####: 1102:                    if (i == lc.len) beep();
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1103:                    break;
        -: 1104:                case 27: /* escape */
        -: 1105:                    /* Re-show original buffer */
    #####: 1106:                    if (i < lc.len) {
branch  0 never executed
branch  1 never executed
    #####: 1107:                        refreshLine(current->prompt, current);
call    0 never executed
        -: 1108:                    }
        -: 1109:                    stop = 1;
        -: 1110:                    break;
        -: 1111:                default:
        -: 1112:                    /* Update buffer and return */
    #####: 1113:                    if (i < lc.len) {
branch  0 never executed
branch  1 never executed
    #####: 1114:                        set_current(current,lc.cvec[i]);
call    0 never executed
        -: 1115:                    }
        -: 1116:                    stop = 1;
        -: 1117:                    break;
        -: 1118:            }
        -: 1119:        }
        -: 1120:    }
        -: 1121:
    #####: 1122:    freeCompletions(&lc);
call    0 never executed
    #####: 1123:    return c; /* Return last read character */
        -: 1124:}
        -: 1125:
        -: 1126:/* Register a callback function to be called for tab-completion.
        -: 1127:   Returns the prior callback so that the caller may (if needed)
        -: 1128:   restore it when done. */
function linenoiseSetCompletionCallback called 0 returned 0% blocks executed 0%
    #####: 1129:linenoiseCompletionCallback * linenoiseSetCompletionCallback(linenoiseCompletionCallback *fn) {
    #####: 1130:    linenoiseCompletionCallback * old = completionCallback;
    #####: 1131:    completionCallback = fn;
    #####: 1132:    return old;
        -: 1133:}
        -: 1134:
function linenoiseAddCompletion called 0 returned 0% blocks executed 0%
    #####: 1135:void linenoiseAddCompletion(linenoiseCompletions *lc, const char *str) {
    #####: 1136:    lc->cvec = (char **)realloc(lc->cvec,sizeof(char*)*(lc->len+1));
    #####: 1137:    lc->cvec[lc->len++] = strdup(str);
call    0 never executed
    #####: 1138:}
        -: 1139:
        -: 1140:#endif
        -: 1141:
function linenoiseEdit called 0 returned 0% blocks executed 0%
    #####: 1142:static int linenoiseEdit(struct current *current) {
        -: 1143:    int history_index = 0;
        -: 1144:
        -: 1145:    /* The latest history entry is always our current buffer, that
        -: 1146:     * initially is just an empty string. */
    #####: 1147:    linenoiseHistoryAdd("");
call    0 never executed
        -: 1148:
    #####: 1149:    set_current(current, "");
call    0 never executed
    #####: 1150:    refreshLine(current->prompt, current);
call    0 never executed
        -: 1151:
        -: 1152:    while(1) {
        -: 1153:        int dir = -1;
        -: 1154:        int c = fd_read(current);
        -: 1155:
        -: 1156:#ifndef NO_COMPLETION
        -: 1157:        /* Only autocomplete when the callback is set. It returns < 0 when
        -: 1158:         * there was an error reading from fd. Otherwise it will return the
        -: 1159:         * character that should be handled next. */
    #####: 1160:        if (c == '\t' && current->pos == current->chars && completionCallback != NULL) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1161:            c = completeLine(current);
call    0 never executed
        -: 1162:            /* Return on errors */
    #####: 1163:            if (c < 0) return current->len;
branch  0 never executed
branch  1 never executed
        -: 1164:            /* Read next character when 0 */
    #####: 1165:            if (c == 0) continue;
branch  0 never executed
branch  1 never executed
        -: 1166:        }
        -: 1167:#endif
        -: 1168:
        -: 1169:process_char:
    #####: 1170:        if (c == -1) return current->len;
branch  0 never executed
branch  1 never executed
        -: 1171:#ifdef USE_TERMIOS
    #####: 1172:        if (c == 27) {   /* escape sequence */
branch  0 never executed
branch  1 never executed
    #####: 1173:            c = check_special(current->fd);
call    0 never executed
        -: 1174:        }
        -: 1175:#endif
    #####: 1176:        switch(c) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
branch 21 never executed
branch 22 never executed
        -: 1177:        case '\r':    /* enter */
    #####: 1178:            history_len--;
    #####: 1179:            free(history[history_len]);
    #####: 1180:            return current->len;
        -: 1181:        case ctrl('C'):     /* ctrl-c */
    #####: 1182:            errno = EAGAIN;
call    0 never executed
    #####: 1183:            return -1;
        -: 1184:        case 127:   /* backspace */
        -: 1185:        case ctrl('H'):
    #####: 1186:            if (remove_char(current, current->pos - 1) == 1) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1187:                refreshLine(current->prompt, current);
call    0 never executed
        -: 1188:            }
        -: 1189:            break;
        -: 1190:        case ctrl('D'):     /* ctrl-d */
    #####: 1191:            if (current->len == 0) {
branch  0 never executed
branch  1 never executed
        -: 1192:                /* Empty line, so EOF */
    #####: 1193:                history_len--;
    #####: 1194:                free(history[history_len]);
    #####: 1195:                return -1;
        -: 1196:            }
        -: 1197:            /* Otherwise fall through to delete char to right of cursor */
        -: 1198:        case SPECIAL_DELETE:
    #####: 1199:            if (remove_char(current, current->pos) == 1) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1200:                refreshLine(current->prompt, current);
call    0 never executed
        -: 1201:            }
        -: 1202:            break;
        -: 1203:        case SPECIAL_INSERT:
        -: 1204:            /* Ignore. Expansion Hook.
        -: 1205:             * Future possibility: Toggle Insert/Overwrite Modes
        -: 1206:             */
        -: 1207:            break;
        -: 1208:        case ctrl('W'):    /* ctrl-w, delete word at left. save deleted chars */
        -: 1209:            /* eat any spaces on the left */
        -: 1210:            {
    #####: 1211:                int pos = current->pos;
    #####: 1212:                while (pos > 0 && get_char(current, pos - 1) == ' ') {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1213:                    pos--;
        -: 1214:                }
        -: 1215:
        -: 1216:                /* now eat any non-spaces on the left */
    #####: 1217:                while (pos > 0 && get_char(current, pos - 1) != ' ') {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1218:                    pos--;
        -: 1219:                }
        -: 1220:
    #####: 1221:                if (remove_chars(current, pos, current->pos - pos)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1222:                    refreshLine(current->prompt, current);
call    0 never executed
        -: 1223:                }
        -: 1224:            }
        -: 1225:            break;
        -: 1226:        case ctrl('R'):    /* ctrl-r */
        -: 1227:            {
        -: 1228:                /* Display the reverse-i-search prompt and process chars */
        -: 1229:                char rbuf[50];
        -: 1230:                char rprompt[80];
        -: 1231:                int rchars = 0;
        -: 1232:                int rlen = 0;
    #####: 1233:                int searchpos = history_len - 1;
        -: 1234:
    #####: 1235:                rbuf[0] = 0;
        -: 1236:                while (1) {
        -: 1237:                    int n = 0;
        -: 1238:                    const char *p = NULL;
        -: 1239:                    int skipsame = 0;
        -: 1240:                    int searchdir = -1;
        -: 1241:
    #####: 1242:                    snprintf(rprompt, sizeof(rprompt), "(reverse-i-search)'%s': ", rbuf);
    #####: 1243:                    refreshLine(rprompt, current);
call    0 never executed
        -: 1244:                    c = fd_read(current);
    #####: 1245:                    if (c == ctrl('H') || c == 127) {
branch  0 never executed
branch  1 never executed
    #####: 1246:                        if (rchars) {
branch  0 never executed
branch  1 never executed
    #####: 1247:                            int p = utf8_index(rbuf, --rchars);
    #####: 1248:                            rbuf[p] = 0;
    #####: 1249:                            rlen = strlen(rbuf);
        -: 1250:                        }
    #####: 1251:                        continue;
        -: 1252:                    }
        -: 1253:#ifdef USE_TERMIOS
    #####: 1254:                    if (c == 27) {
branch  0 never executed
branch  1 never executed
    #####: 1255:                        c = check_special(current->fd);
call    0 never executed
        -: 1256:                    }
        -: 1257:#endif
    #####: 1258:                    if (c == ctrl('P') || c == SPECIAL_UP) {
branch  0 never executed
branch  1 never executed
        -: 1259:                        /* Search for the previous (earlier) match */
    #####: 1260:                        if (searchpos > 0) {
branch  0 never executed
branch  1 never executed
    #####: 1261:                            searchpos--;
        -: 1262:                        }
        -: 1263:                        skipsame = 1;
        -: 1264:                    }
    #####: 1265:                    else if (c == ctrl('N') || c == SPECIAL_DOWN) {
branch  0 never executed
branch  1 never executed
        -: 1266:                        /* Search for the next (later) match */
    #####: 1267:                        if (searchpos < history_len) {
branch  0 never executed
branch  1 never executed
    #####: 1268:                            searchpos++;
        -: 1269:                        }
        -: 1270:                        searchdir = 1;
        -: 1271:                        skipsame = 1;
        -: 1272:                    }
    #####: 1273:                    else if (c >= ' ') {
branch  0 never executed
branch  1 never executed
    #####: 1274:                        if (rlen >= (int)sizeof(rbuf) + 3) {
branch  0 never executed
branch  1 never executed
    #####: 1275:                            continue;
        -: 1276:                        }
        -: 1277:
    #####: 1278:                        n = utf8_getchars(rbuf + rlen, c);
    #####: 1279:                        rlen += n;
    #####: 1280:                        rchars++;
    #####: 1281:                        rbuf[rlen] = 0;
        -: 1282:
        -: 1283:                        /* Adding a new char resets the search location */
    #####: 1284:                        searchpos = history_len - 1;
        -: 1285:                    }
        -: 1286:                    else {
        -: 1287:                        /* Exit from incremental search mode */
        -: 1288:                        break;
        -: 1289:                    }
        -: 1290:
        -: 1291:                    /* Now search through the history for a match */
    #####: 1292:                    for (; searchpos >= 0 && searchpos < history_len; searchpos += searchdir) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1293:                        p = strstr(history[searchpos], rbuf);
    #####: 1294:                        if (p) {
branch  0 never executed
branch  1 never executed
        -: 1295:                            /* Found a match */
    #####: 1296:                            if (skipsame && strcmp(history[searchpos], current->buf) == 0) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1297:                                /* But it is identical, so skip it */
    #####: 1298:                                continue;
        -: 1299:                            }
        -: 1300:                            /* Copy the matching line and set the cursor position */
    #####: 1301:                            set_current(current,history[searchpos]);
call    0 never executed
    #####: 1302:                            current->pos = utf8_strlen(history[searchpos], p - history[searchpos]);
branch  0 never executed
branch  1 never executed
    #####: 1303:                            break;
        -: 1304:                        }
        -: 1305:                    }
    #####: 1306:                    if (!p && n) {
branch  0 never executed
branch  1 never executed
        -: 1307:                        /* No match, so don't add it */
    #####: 1308:                        rchars--;
    #####: 1309:                        rlen -= n;
    #####: 1310:                        rbuf[rlen] = 0;
        -: 1311:                    }
        -: 1312:                }
    #####: 1313:                if (c == ctrl('G') || c == ctrl('C')) {
branch  0 never executed
branch  1 never executed
        -: 1314:                    /* ctrl-g terminates the search with no effect */
    #####: 1315:                    set_current(current, "");
call    0 never executed
        -: 1316:                    c = 0;
        -: 1317:                }
    #####: 1318:                else if (c == ctrl('J')) {
branch  0 never executed
branch  1 never executed
        -: 1319:                    /* ctrl-j terminates the search leaving the buffer in place */
        -: 1320:                    c = 0;
        -: 1321:                }
        -: 1322:                /* Go process the char normally */
    #####: 1323:                refreshLine(current->prompt, current);
call    0 never executed
        -: 1324:                goto process_char;
        -: 1325:            }
        -: 1326:            break;
        -: 1327:        case ctrl('T'):    /* ctrl-t */
    #####: 1328:            if (current->pos > 0 && current->pos <= current->chars) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1329:                /* If cursor is at end, transpose the previous two chars */
    #####: 1330:                int fixer = (current->pos == current->chars);
    #####: 1331:                c = get_char(current, current->pos - fixer);
    #####: 1332:                remove_char(current, current->pos - fixer);
call    0 never executed
    #####: 1333:                insert_char(current, current->pos - 1, c);
call    0 never executed
    #####: 1334:                refreshLine(current->prompt, current);
call    0 never executed
        -: 1335:            }
        -: 1336:            break;
        -: 1337:        case ctrl('V'):    /* ctrl-v */
    #####: 1338:            if (has_room(current, 3)) {
branch  0 never executed
branch  1 never executed
        -: 1339:                /* Insert the ^V first */
    #####: 1340:                if (insert_char(current, current->pos, c)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1341:                    refreshLine(current->prompt, current);
call    0 never executed
        -: 1342:                    /* Now wait for the next char. Can insert anything except \0 */
        -: 1343:                    c = fd_read(current);
        -: 1344:
        -: 1345:                    /* Remove the ^V first */
    #####: 1346:                    remove_char(current, current->pos - 1);
call    0 never executed
    #####: 1347:                    if (c != -1) {
branch  0 never executed
branch  1 never executed
        -: 1348:                        /* Insert the actual char */
    #####: 1349:                        insert_char(current, current->pos, c);
call    0 never executed
        -: 1350:                    }
    #####: 1351:                    refreshLine(current->prompt, current);
call    0 never executed
        -: 1352:                }
        -: 1353:            }
        -: 1354:            break;
        -: 1355:        case ctrl('B'):
        -: 1356:        case SPECIAL_LEFT:
    #####: 1357:            if (current->pos > 0) {
branch  0 never executed
branch  1 never executed
    #####: 1358:                current->pos--;
    #####: 1359:                refreshLine(current->prompt, current);
call    0 never executed
        -: 1360:            }
        -: 1361:            break;
        -: 1362:        case ctrl('F'):
        -: 1363:        case SPECIAL_RIGHT:
    #####: 1364:            if (current->pos < current->chars) {
branch  0 never executed
branch  1 never executed
    #####: 1365:                current->pos++;
    #####: 1366:                refreshLine(current->prompt, current);
call    0 never executed
        -: 1367:            }
        -: 1368:            break;
        -: 1369:        case SPECIAL_PAGE_UP:
    #####: 1370:          dir = history_len - history_index - 1; /* move to start of history */
    #####: 1371:          goto history_navigation;
        -: 1372:        case SPECIAL_PAGE_DOWN:
    #####: 1373:          dir = -history_index; /* move to 0 == end of history, i.e. current */
    #####: 1374:          goto history_navigation;
        -: 1375:        case ctrl('P'):
        -: 1376:        case SPECIAL_UP:
        -: 1377:            dir = 1;
    #####: 1378:          goto history_navigation;
        -: 1379:        case ctrl('N'):
        -: 1380:        case SPECIAL_DOWN:
        -: 1381:history_navigation:
    #####: 1382:            if (history_len > 1) {
branch  0 never executed
branch  1 never executed
        -: 1383:                /* Update the current history entry before to
        -: 1384:                 * overwrite it with tne next one. */
    #####: 1385:                free(history[history_len - 1 - history_index]);
    #####: 1386:                history[history_len - 1 - history_index] = strdup(current->buf);
call    0 never executed
        -: 1387:                /* Show the new entry */
    #####: 1388:                history_index += dir;
    #####: 1389:                if (history_index < 0) {
branch  0 never executed
branch  1 never executed
        -: 1390:                    history_index = 0;
        -: 1391:                    break;
    #####: 1392:                } else if (history_index >= history_len) {
branch  0 never executed
branch  1 never executed
    #####: 1393:                    history_index = history_len - 1;
    #####: 1394:                    break;
        -: 1395:                }
    #####: 1396:                set_current(current, history[history_len - 1 - history_index]);
call    0 never executed
    #####: 1397:                refreshLine(current->prompt, current);
call    0 never executed
        -: 1398:            }
        -: 1399:            break;
        -: 1400:        case ctrl('A'): /* Ctrl+a, go to the start of the line */
        -: 1401:        case SPECIAL_HOME:
    #####: 1402:            current->pos = 0;
    #####: 1403:            refreshLine(current->prompt, current);
call    0 never executed
    #####: 1404:            break;
        -: 1405:        case ctrl('E'): /* ctrl+e, go to the end of the line */
        -: 1406:        case SPECIAL_END:
    #####: 1407:            current->pos = current->chars;
    #####: 1408:            refreshLine(current->prompt, current);
call    0 never executed
    #####: 1409:            break;
        -: 1410:        case ctrl('U'): /* Ctrl+u, delete to beginning of line, save deleted chars. */
    #####: 1411:            if (remove_chars(current, 0, current->pos)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1412:                refreshLine(current->prompt, current);
call    0 never executed
        -: 1413:            }
        -: 1414:            break;
        -: 1415:        case ctrl('K'): /* Ctrl+k, delete from current to end of line, save deleted chars. */
    #####: 1416:            if (remove_chars(current, current->pos, current->chars - current->pos)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1417:                refreshLine(current->prompt, current);
call    0 never executed
        -: 1418:            }
        -: 1419:            break;
        -: 1420:        case ctrl('Y'): /* Ctrl+y, insert saved chars at current position */
    #####: 1421:            if (current->capture && insert_chars(current, current->pos, current->capture)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1422:                refreshLine(current->prompt, current);
call    0 never executed
        -: 1423:            }
        -: 1424:            break;
        -: 1425:        case ctrl('L'): /* Ctrl+L, clear screen */
        -: 1426:            clearScreen(current);
        -: 1427:            /* Force recalc of window size for serial terminals */
    #####: 1428:            current->cols = 0;
    #####: 1429:            refreshLine(current->prompt, current);
call    0 never executed
    #####: 1430:            break;
        -: 1431:        default:
        -: 1432:            /* Only tab is allowed without ^V */
    #####: 1433:            if (c == '\t' || c >= ' ') {
branch  0 never executed
branch  1 never executed
    #####: 1434:                if (insert_char(current, current->pos, c) == 1) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1435:                    refreshLine(current->prompt, current);
call    0 never executed
        -: 1436:                }
        -: 1437:            }
        -: 1438:            break;
        -: 1439:        }
        -: 1440:    }
        -: 1441:    return current->len;
        -: 1442:}
        -: 1443:
function linenoiseColumns called 0 returned 0% blocks executed 0%
    #####: 1444:int linenoiseColumns(void)
        -: 1445:{
        -: 1446:    struct current current;
    #####: 1447:    enableRawMode (&current);
call    0 never executed
    #####: 1448:    getWindowSize (&current);
call    0 never executed
    #####: 1449:    disableRawMode (&current);
call    0 never executed
    #####: 1450:    return current.cols;
        -: 1451:}
        -: 1452:
function linenoise called 0 returned 0% blocks executed 0%
    #####: 1453:char *linenoise(const char *prompt)
        -: 1454:{
        -: 1455:    int count;
        -: 1456:    struct current current;
        -: 1457:    char buf[LINENOISE_MAX_LINE];
        -: 1458:
    #####: 1459:    if (enableRawMode(&current) == -1) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1460:        printf("%s", prompt);
call    0 never executed
    #####: 1461:        fflush(stdout);
call    0 never executed
    #####: 1462:        if (fgets(buf, sizeof(buf), stdin) == NULL) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1463:            return NULL;
        -: 1464:        }
    #####: 1465:        count = strlen(buf);
    #####: 1466:        if (count && buf[count-1] == '\n') {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1467:            count--;
    #####: 1468:            buf[count] = '\0';
        -: 1469:        }
        -: 1470:    }
        -: 1471:    else
        -: 1472:    {
    #####: 1473:        current.buf = buf;
    #####: 1474:        current.bufmax = sizeof(buf);
    #####: 1475:        current.len = 0;
    #####: 1476:        current.chars = 0;
    #####: 1477:        current.pos = 0;
    #####: 1478:        current.prompt = prompt;
    #####: 1479:        current.capture = NULL;
        -: 1480:
    #####: 1481:        count = linenoiseEdit(&current);
call    0 never executed
        -: 1482:
    #####: 1483:        disableRawMode(&current);
call    0 never executed
    #####: 1484:        printf("\n");
call    0 never executed
        -: 1485:
    #####: 1486:        free(current.capture);
    #####: 1487:        if (count == -1) {
branch  0 never executed
branch  1 never executed
        -: 1488:            return NULL;
        -: 1489:        }
        -: 1490:    }
    #####: 1491:    return strdup(buf);
call    0 never executed
        -: 1492:}
        -: 1493:
        -: 1494:/* Using a circular buffer is smarter, but a bit more complex to handle. */
function linenoiseHistoryAdd called 0 returned 0% blocks executed 0%
    #####: 1495:int linenoiseHistoryAdd(const char *line) {
        -: 1496:    char *linecopy;
        -: 1497:
    #####: 1498:    if (history_max_len == 0) return 0;
branch  0 never executed
branch  1 never executed
    #####: 1499:    if (history == NULL) {
branch  0 never executed
branch  1 never executed
    #####: 1500:        history = (char **)malloc(sizeof(char*)*history_max_len);
    #####: 1501:        if (history == NULL) return 0;
branch  0 never executed
branch  1 never executed
    #####: 1502:        memset(history,0,(sizeof(char*)*history_max_len));
        -: 1503:    }
        -: 1504:
        -: 1505:    /* do not insert duplicate lines into history */
    #####: 1506:    if (history_len > 0 && strcmp(line, history[history_len - 1]) == 0) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1507:        return 0;
        -: 1508:    }
        -: 1509:
    #####: 1510:    linecopy = strdup(line);
call    0 never executed
    #####: 1511:    if (!linecopy) return 0;
branch  0 never executed
branch  1 never executed
    #####: 1512:    if (history_len == history_max_len) {
branch  0 never executed
branch  1 never executed
    #####: 1513:        free(history[0]);
    #####: 1514:        memmove(history,history+1,sizeof(char*)*(history_max_len-1));
    #####: 1515:        history_len--;
        -: 1516:    }
    #####: 1517:    history[history_len] = linecopy;
    #####: 1518:    history_len++;
    #####: 1519:    return 1;
        -: 1520:}
        -: 1521:
function linenoiseHistoryGetMaxLen called 0 returned 0% blocks executed 0%
    #####: 1522:int linenoiseHistoryGetMaxLen(void) {
    #####: 1523:    return history_max_len;
        -: 1524:}
        -: 1525:
function linenoiseHistorySetMaxLen called 0 returned 0% blocks executed 0%
    #####: 1526:int linenoiseHistorySetMaxLen(int len) {
        -: 1527:    char **newHistory;
        -: 1528:
    #####: 1529:    if (len < 1) return 0;
branch  0 never executed
branch  1 never executed
    #####: 1530:    if (history) {
branch  0 never executed
branch  1 never executed
    #####: 1531:        int tocopy = history_len;
        -: 1532:
    #####: 1533:        newHistory = (char **)malloc(sizeof(char*)*len);
    #####: 1534:        if (newHistory == NULL) return 0;
branch  0 never executed
branch  1 never executed
        -: 1535:
        -: 1536:        /* If we can't copy everything, free the elements we'll not use. */
    #####: 1537:        if (len < tocopy) {
branch  0 never executed
branch  1 never executed
        -: 1538:            int j;
        -: 1539:
    #####: 1540:            for (j = 0; j < tocopy-len; j++) free(history[j]);
branch  0 never executed
branch  1 never executed
        -: 1541:            tocopy = len;
        -: 1542:        }
    #####: 1543:        memset(newHistory,0,sizeof(char*)*len);
    #####: 1544:        memcpy(newHistory,history+(history_len-tocopy), sizeof(char*)*tocopy);
    #####: 1545:        free(history);
    #####: 1546:        history = newHistory;
        -: 1547:    }
    #####: 1548:    history_max_len = len;
    #####: 1549:    if (history_len > history_max_len)
branch  0 never executed
branch  1 never executed
    #####: 1550:        history_len = history_max_len;
        -: 1551:    return 1;
        -: 1552:}
        -: 1553:
        -: 1554:/* Save the history in the specified file. On success 0 is returned
        -: 1555: * otherwise -1 is returned. */
function linenoiseHistorySave called 0 returned 0% blocks executed 0%
    #####: 1556:int linenoiseHistorySave(const char *filename) {
    #####: 1557:    FILE *fp = fopen(filename,"w");
call    0 never executed
        -: 1558:    int j;
        -: 1559:
    #####: 1560:    if (fp == NULL) return -1;
branch  0 never executed
branch  1 never executed
    #####: 1561:    for (j = 0; j < history_len; j++) {
branch  0 never executed
branch  1 never executed
    #####: 1562:        const char *str = history[j];
        -: 1563:        /* Need to encode backslash, nl and cr */
    #####: 1564:        while (*str) {
branch  0 never executed
branch  1 never executed
    #####: 1565:            if (*str == '\\') {
branch  0 never executed
branch  1 never executed
    #####: 1566:                fputs("\\\\", fp);
call    0 never executed
        -: 1567:            }
    #####: 1568:            else if (*str == '\n') {
branch  0 never executed
branch  1 never executed
    #####: 1569:                fputs("\\n", fp);
call    0 never executed
        -: 1570:            }
    #####: 1571:            else if (*str == '\r') {
branch  0 never executed
branch  1 never executed
    #####: 1572:                fputs("\\r", fp);
call    0 never executed
        -: 1573:            }
        -: 1574:            else {
    #####: 1575:                fputc(*str, fp);
call    0 never executed
        -: 1576:            }
    #####: 1577:            str++;
        -: 1578:        }
    #####: 1579:        fputc('\n', fp);
call    0 never executed
        -: 1580:    }
        -: 1581:
    #####: 1582:    fclose(fp);
call    0 never executed
    #####: 1583:    return 0;
        -: 1584:}
        -: 1585:
        -: 1586:/* Load the history from the specified file. If the file does not exist
        -: 1587: * zero is returned and no operation is performed.
        -: 1588: *
        -: 1589: * If the file exists and the operation succeeded 0 is returned, otherwise
        -: 1590: * on error -1 is returned. */
function linenoiseHistoryLoad called 0 returned 0% blocks executed 0%
    #####: 1591:int linenoiseHistoryLoad(const char *filename) {
    #####: 1592:    FILE *fp = fopen(filename,"r");
call    0 never executed
        -: 1593:    char buf[LINENOISE_MAX_LINE];
        -: 1594:
    #####: 1595:    if (fp == NULL) return -1;
branch  0 never executed
branch  1 never executed
        -: 1596:
    #####: 1597:    while (fgets(buf,LINENOISE_MAX_LINE,fp) != NULL) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1598:        char *src, *dest;
        -: 1599:
        -: 1600:        /* Decode backslash escaped values */
    #####: 1601:        for (src = dest = buf; *src; src++) {
branch  0 never executed
branch  1 never executed
        -: 1602:            char ch = *src;
        -: 1603:
    #####: 1604:            if (ch == '\\') {
branch  0 never executed
branch  1 never executed
    #####: 1605:                src++;
    #####: 1606:                if (*src == 'n') {
branch  0 never executed
branch  1 never executed
        -: 1607:                    ch = '\n';
        -: 1608:                }
    #####: 1609:                else if (*src == 'r') {
branch  0 never executed
branch  1 never executed
        -: 1610:                    ch = '\r';
        -: 1611:                } else {
        -: 1612:                    ch = *src;
        -: 1613:                }
        -: 1614:            }
    #####: 1615:            *dest++ = ch;
        -: 1616:        }
        -: 1617:        /* Remove trailing newline */
    #####: 1618:        if (dest != buf && (dest[-1] == '\n' || dest[-1] == '\r')) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1619:            dest--;
        -: 1620:        }
    #####: 1621:        *dest = 0;
        -: 1622:
    #####: 1623:        linenoiseHistoryAdd(buf);
call    0 never executed
        -: 1624:    }
    #####: 1625:    fclose(fp);
call    0 never executed
    #####: 1626:    return 0;
        -: 1627:}
        -: 1628:
        -: 1629:/* Provide access to the history buffer.
        -: 1630: *
        -: 1631: * If 'len' is not NULL, the length is stored in *len.
        -: 1632: */
function linenoiseHistory called 0 returned 0% blocks executed 0%
    #####: 1633:char **linenoiseHistory(int *len) {
    #####: 1634:    if (len) {
branch  0 never executed
branch  1 never executed
    #####: 1635:        *len = history_len;
        -: 1636:    }
    #####: 1637:    return history;
        -: 1638:}
